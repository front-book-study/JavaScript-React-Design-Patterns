### 11.3 접두사 네임스페이스 패턴
단일 전역 변수에 대한 문제에 대한 해결책으로 제안되었다.

단일 전역 변수에 대한 문제점
- 예측 불가능한 상태 변화 
    - 전역 변수는 어디서든 읽고/쓰기가 가능하기 때문에 어디서 값을 바꿨는지 추적이 거의 불가능함
- 강한 결합도
    - 전역 변수를 쓰는 모든 코드가 그 변수에 암묵적으로 의존하게 된다.

*통제된 전역*에서만 사용 할 것
- 상수
- 환경 설정 값
- 읽기 전용
- 변경이 거의 없는 값


#### 접두사 네임스페이스 사용법
고유한 접두사를 선정한 다음에 모든 메서드, 변수, 객체를 접두사 뒤에 붙여서 정의한다.
```
// 접두사 myApplication_
const myApplication_propoertyA = {};
const myApplication_propoertyB = {};
```
장점 - 전역에서 특정 변수와 이름이 겹칠 가능성을 효과적으로 줄인다. 하지만 스스로 고유한 이름을 가진 객체도 같은 효과를 낼 수 있다.
문제점 - 애플리케이션이 커짐에 따라 많은 전역 객체가 생성된다.

### 11.4 객체 리터럴 표기법 패턴
객체 리터럴 표기법은 일종의 객체로, 키와 값으로 이뤄진 집합을 가진다. 각각의 키와 값은 콜론(:)으로 구분된다.
또한 키 자체가 새로운 네임스페이스가 될 수 있다. 

객체 리터럴 표기법 패턴은 전역 네임스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성하는데 도움을 준다. 특히 쉽게 읽을 수 있고, 깊은 중첩을 지원하는 구조를 구현할 때 매우 유용하다. 

JSON은 사실 객체 리터럴 표기법의 서브셋이며, 문법적으로 약간의 차이만 있다.

### 11.5 중첩 네임스페이스 패턴
객체 리터럴 패턴을 발전 시킨 형태로 중첩 네임스페이스 패턴은 다른 패턴에 비해 충돌 가능성이 낮은 편이다. 
(같은 이름의 네임스페이스가 존재하더라도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문)
```
// 중첩된 하위 속성을 정의할 때에도 비슷한 방법으로 객체 존재 여부를 확인한다.
myApp.routers = myApp.routers || {};
myApp.model = myApp.model || {};
myApp.model.special = myApp.model.special || {};

//필요에 따라 중첩 네임스페이스를 복잡하게 만들 수도 있다.
myApp.utilites.charting.html5.plotGraph(/*..*/)

//인덱싱된 속성으로 선언할 수도 있다.
myApp["routers"] = myApp["routers"] || {};
```
하나 주의할 점은 브라우저의 자바스크립트 엔진이 먼저 myApp 객체의 위치를 찾은 후 실제로 사용하고자 하는 함수가 위치한 곳까지 파고들어가야 한다는 점이다.
이러한 과정 때문에 참조해야할 일이 더 많아질 수도 있지만, 단일 객체 네임스페이스 패턴과 성능차이가 크기 않다고 한다.

### 11.6 즉시 실행 함수 표현식 패턴
자바스크립트에서는 즉시 실행함수로 정의된 내부의 변수와 함수 모두 외부에서 접근할 수 없다. 따라서 함수를 호출하는 것만으로도 쉽게 코드의 은닉성을 구현할 수 있다.
즉시 실행함수는 애플리케이션의 로직을 캡슐화 하여 전역 네임스페이스로부터 보호하는데 널리 사용되는 방법이다.
```
const namespace = namespace || {};

// 함수 매개변수로 네임스페이스 객체를 전달하고,
// 공용 메서드와 속성을 할당한다.
((o) => {
  o.foo = "foo";
  o.bar = () => "bar";
})(namespace);

console.log(namespace)
```


```

// 네임스페이스의 이름과 undefined를 인자로 전달한다.
// 1. 네임스페이스를 지역적으로 변경할 수 있고,
// 함수 컨텍스트 밖에서 덮어쓰여지지 않는다. 
// 2. undefined 값이 정말로 undefined임을 보장한다.
// ES5 이전의 undefined는 변경될 수 있기 때문에 필요한 과정이다.

((namespace, undefined) => {
  // 비공개 속성들
  const foo = "foo";
  const bar = "bar";
  
  // 공개 메서드와 속성
  namespace.foobar = "foobar";
  namespace.sayHello = () => {
    speak("hello world");
  }

  // 비공개 메서드
  function speak(msg) {
    console.log(`You said:${msg}`)
  }
  
  // 전역 네임스페이스에 "namespace"가 존재하는지 검사하고
  // 없을 경우 window.namespace에 객체 리터럴을 할당한다.
})(window.namespace = window.namespace || {});

```

### 11.7 네임 스페이스 주입 패턴
즉시 실행 함수 패턴의 또 다른 변형이다. 이 패턴에서는 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에 메서드와 속성을 주입힌다. 네임스페이스 주입 패턴의 장점은 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다는 점이다. 또한 이후에 확장될 기본 메서드(ex.getter, setter)에 적용할 때 유용하다. 

네임스페이스 주입패턴의 단점은 같은 목적을 달성하는 더 쉽고 효율적인 방법이 존재할 수 있다는 점이다. 


### 11.8 고급 네임스페이스 패턴
#### 11.8.1 중첩 네임스페이스 자동화 패턴
중첩 네임스페이스는 코드에 체계적이고 계층적인 구조를 만들어준다.
이 패턴의 한가지 명백한 단점은 추가하고자 하는 계층이 늘어날수록 최상위 네임스페이스에 더 많은 하위 객체들이 정의되어야 한다는 점이다.특히 애플리케이션이 복잡해져서 중첩의 깊이가 커질수록 매우 번거로워질 수 있다.

#### 11.8.2 의존성 선언 패턴
객체의 로컬 참조가 전체적인 조회 시간을 단축하는 원칙을 네임스페이스에 적용한 패턴
함수나 모듈에서 사용할 로컬 네임스페이스를 함수 영역의 상단에 선언할것을 권장하며(단일 변수 패턴 사용) 이렇게 선언하면 의존성을 찾고 해석하는 시간을 줄이는 장점이 있다. 또한 필요할 때 동적으로 모듈을 네임스페이스에 추가하는 확장 가능한 아키텍처를 사용하는 경우에도 효과적이다. 

저자의 생각에 의존성 선언 패턴은 모듈 단위로 작업할 때 가장 효과적인데, 이 패턴은 특정 메서드 그룹에서 사용될 네임스페이스를 지역화하기 때문이다. 다만 네임스페이스 간의 의존성이 중복되는 경우가 많다면 함수 단위로 네임스페이스를 지역화하는 것은 피하는 것이 좋다. -> 이럴대는 네임스페이스를 상위 레벨에서 정의하고 모든 함수가 접근할 수 있도록 하는 것이 바람직하다.

#### 11.8.3 심층 객체 확장 패턴
자동 네임스페이 생성에 대한 또다른 해결책으로, 객체 리터럴 표기법으로 선언된 네임스페이스는 다른 객체와 쉽게 확장(또는 병합)될 수 있다. 병합 이후에는 두 네임스페이스의 속성과 함수 모두를 동일한 네임스페이스에서 접근할 수 있다.



