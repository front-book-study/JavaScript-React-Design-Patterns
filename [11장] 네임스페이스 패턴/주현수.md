## 11. 네임스페이스 패턴

책에서는 대규모 스크립트나 애플리케이션 환경에서 네임스페이스의 중요성을 강조한다.
특히 페이지 내에 여러 스크립트가 공존할 때 발생하는 전역 변수 및 메서드 이름 충돌 문제, 그리고 서드파티 스크립트와의 충돌 가능성을 주요 문제로 제기한다.

이런 문제의식은 모듈 개념이 존재하지 않던 시절 자바스크립트의 한계를 보여주며, 네임스페이스 패턴은 이를 해결하기 위한 대표적인 설계 방식이었다.
즉, 네임스페이스 패턴은 자바스크립트 모듈 시스템이 탄생하게 된 역사적 배경을 이해하는 데 도움 역할을 한다.

다만 현대 자바스크립트 환경에서는 ES Modules를 통해 파일 단위 스코프가 기본적으로 보장되며, import/export 문법을 통해 명시적인 의존성 관리가 가능하다.
이로 인해 과거 네임스페이스 패턴이 해결하고자 했던 문제들은 언어 차원에서 자연스럽게 해결 되고 있다고 생각한다.


## 11.2 단일 전역 변수 패턴 

- 하나의 전역 변수를 주요 참조 객체로 사용하는 방식 
- 단점은 이름이 전역에 있는 순간, 충돌 위험 

## 11.3 접두사 네임 스페이스 패턴 

- 충돌 가능성이 낮은 고유한 접두사를 이름에 붙이자
- 고유한 접두사를 선정한 다음 모든 메서드, 변수, 객체를 이 접두사 뒤에 붙여서 정의
- 
## 11.4 객체 리터럴 표기법
- 접두사 방식의 지저분함을 구조화된 방식으로 해결할 수 있음 
- 전역 네임 스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성할 수 있음. 
- 깊은 중첩 까지 구조 지원 가능 
- JSON이 객체 리터럴 표기법의 서브셋이다. JSON의 탄생 배경이 됨(당시xml로 통신하는 구조의 복잡함 해결)

## 11.5 중첩네임스페이스 
- 객체 리터럴 패턴을 발전시킨 형태 
- 다른 패턴에 비해 충돌 가능성 낮음- 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문

```javascript

const myApp = myApp ||{}
myApp.routers = myApp.routers||{}
myApp.model = myApp.model||{}
myApp.model.special = myApp.model.special ||{}


```
- 브라우저 엔진이 먼저 myApp객체의 위치를 찾은 후 실제 사용하고자하는 함수가 위치한 곳까지 파고 들어가야 함.
- 
## 11.6 즉시 실행 함수 표현식 패턴 
- IIFE는 함수를 정의하자마자 즉시 실행하는 자바스크립트 기술 
- 단일 전역 변수 패턴만 쓰면 MYAPP.user = "admin"처럼 누구나 내부 값을 바꿀 수 있다는 단점

```javascript
const namespace = namespace||{};

((o)=>{
    o.foo = "foo";
    o.bar= ()=> "bar";
    
})(namespace)

console.log(namespace)
```

- 모듈 시스템이 없던 시절 IIFE가 파일간의 독립성을 보장하는 방법

## 11.7 네임스페이스 주입 패턴
- this를 네임스페이스의 프록시로 활용해 특정 네임스페이스에 메서드와 속성을 주입 
- 여러 객체나 네임스페이스에 기능적 동작을 쉽게 적용할 수 있고 이후 확장될 기본 메서드에 적용할 때 유용

```javascript
const myApp = myApp||{}

myApp.utils = {};

(function(){
    let val = 5
    this.getValue = ()=>val
    this.setValue= (newVal)=>  val = newVal
    
    this.tools  = {}
    
}).apply(myApp.utils)

//기능을 확장해 새로운 동작 추가

    (function(){
        this.diagnose = ()=>"diagnosis"
    }).apply(myApp.utils.tools)

```
일반적인 즉시실행 함수도 이 확장기법을 적용할 수 있음.
context를 인자로 받아서 this대신 해당 context를 직접 수정 하는 방식으로 가능 

```javascript
const myApp = myApp || {};
myApp.utils = {};

(function(ctx) { // ctx라는 인자로 네임스페이스를 받음
    let val = 5;
    
    // this 대신 전달받은 ctx에 직접 기능을 붙임
    ctx.getValue = () => val;
    ctx.setValue = (newVal) => val = newVal;
    
    ctx.tools = {};
    
})(myApp.utils);
```

#### 앵거스 크롤의 call 기법 : 컨텍스트와 인자를 자연스럽게 분리

- apply는 객체전체를 통째로 던지는 느낌 반면 call은 context와 arguments를 깔끔하게 분리 

```javascript
const ns = ns||{}

const creator = function(val){
    var val = val ||0;
    this.next = ()=> val++;
    this.reset = ()=>{
        val = 0;
    }
    
    
}

creator.call(ns);
creator.call(ns, 5000) //val 결정 
```

## 11.8 고급 네임 스페이스 패턴

### 중첩 네임 스페이스 자동화 패턴 
- 중첩 네임스페이스는 추가하고자하는 계층이 늘어날 수록 복잡성 높아짐 
- 해결방식 제안: 스토얀 스테파노프,하나의 문자열 인자를 받아 파싱한 후 필요한 객체를 기반으로 네임스페이스에 자동으로 추가하는 방법 
- 저자는 중첩네임스페이스 자동화 패턴을 권장 (개인적 선호도)

```javascript
const myApp = {}

function extend(ns, ns_string){
    const parts = ns_string.split(".");
    let parent = ns
    let pl;
    
    pl = parts.length
    
    for(let i =0; i<pl; i++){
        if(typeof parent[parts[i]] ==="undefined"){
            parent[parts[i]] = {}
        }
        parent=parent[parts[i]]
    }
    return parent
}


const mod = extend(myApp, "module.module2")

console.log(myApp) //{module: {…}}module: module2: {}[[Prototype]]: Object[[Prototype]]: Object
console.log(mod == myApp.module.module2) //true
```
