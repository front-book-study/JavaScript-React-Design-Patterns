### 네임스페이스

코드 단위를 고유한 식별자로 그룹화 한 것

하나의 식별자를 여러 네임스페이스에서 참조할 수 있고, 각 식별자는 중첩된(혹은) 하위 네임스페이스의 계층 구조를 가질 수 있다.

### 이점

- 자바스크립트의 네임스페이스는 전역 네임스페이스 내에 존재하는 다른객체나 변수와의 추돌을 방지함에 있어 유용하다
- 프로그램의 기능들을 체계적으로 구서앟여 코드의 재사용성과 관리의 편의성을 높인다.

## 11.2 단일 전역변수 패턴

하나의 전역변수를 주요한 객체로 사용하는 방식

## 11.3 접두사 네임스페이스 패턴

고유한 접두사를 선정한 다음에 모든 메서드 변수 객체를 접두사 뒤에 붙인다

## 11.4 객체 리터럴 표기법 패턴

키와 값으로 이뤄진 집합을 가짐

키 자체가 새로운 네임스페읏가 된다.

```jsx
myApplication={
	getInfo() {}
	model: {}
}
```

`model` 과 같이 객체 내에 추가 객체 네임스페이스 선언 가능

→ 같은 이름의 기존 변수나 네임스페이스를 쉽게 덮어써버릴 수 잇다.

### 객체 네임스페이스가 존재하는지 확인하고, 만약 존재하지 않는다면 새로 정의하는 방법

```jsx
if(!myApplication) { myApplicaiton = {} }
```

```jsx
const g = globalThis;
g.App ?? = {}
```

## 11.6 즉시 실행함수 표현식 패턴

e.g. 

```jsx
window.namespace = window.namespace || {}
```

es6 이전, “undefined가 변경될 수 있다”는 말은 값이 변하는게 아닌 

undefined라는 이름에 다른 값을 넣을 수 있다는 뜻

## 11,7 네임스페이스 주입 패턴

함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에서 메서드와 속성을 주입

여러 객체나 네임스페이스의 기능적인 동작을 쉽게 적용 가능

### call APi를 사용한 패턴

```jsx
// 나중에 사용한 네임스페이스를 정의
const ns = ns || {}
const ns2 = ns2 || {}

// 모듈/네임스페으스 생성자
const createor = function(val) {
	var val = val || 0
	
	this.next = () => val ++
	
	this.reset = () => {
		val = 0;
	}
}
creator.call(ns)
// 이제 ns.next와 ns.reset 메서드를 사용가능

creator.call(ns2, 5000)
// ns3에도 같은 메서드가 생성되지만
// val 의 초기값이 5000으로 덮어씌워진다
```

## 11.8 고급 네임스페이스 패턴

### 11.8.1 중첩 네임스페이스 자동화 패턴

```jsx
// 문자열 형식의 네임스페이스를 파싱하고
// 자동으로 중첩 네임스페이스를 생성해주는 간편한 함수입니다.

function extend (ns, ns_string) {...}

extend(myApp,moduleA.moduleB.moduleC)

//실행 결과
const myApp = {
	moduleA: {
		moduleB: {
			moduleC:{}
		}
	}
}
```

### 11.8.2 의존성 선언 패턴

```jsx
//로컬변수에 캐싱한 참조를 사용합니다.

const utils = myApp.utilities
const maths = utils.math

// 로컬변수를 상요하는 이 방식은 중첩 네임스페이스에
// 수백, 수천번 호출이 발생하는 경우에만 성능이 향상된다.
```
