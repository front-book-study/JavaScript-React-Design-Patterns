## 리액트 hooks

- 클래스 컴포넌트 : hooks 도입되기 전에 컴포넌트에 상태, 라이프사이클 메서드를 추가하려면 클래스 컴포넌트 사용해야만 했음.
 - 생성자 함수 내부에서 상태 정의
 - 라이프사이클 메서드 : componentDidMount, componentWillUnmount 등
 - 추가적인 로직을 구현하기 위한 커스텀 메서드 : 바인딩 필요

- 클래스 컴포넌트의 단점
  - 상태, 라이프사이클 메소드 필요한 경우 함수에서 클래스 컴포넌트로 변경해야함.
  - Wrapper Hell 문제 발생 : 중첩된 컴포넌트간에 코드를 공유하기 위해 여러 겹의 컴포넌트 사용시 발생. 데이터 흐름 파악 어려워서 디버깅이 어려움.
  - 복잡성 증가 : 컴포넌트 크기 빠르게 증가, 내부 로직이 구조화 되지 않음, 디버깅 및 성능 최적화를 어렵게 만듦

- Hooks의 등장
  - 함수형 컴포넌트에 상태 추가 : useState
  - 라이블 사이클 메소드 사용하지 않고 라이프사이클 관리 가능 : useEffect (componentDidMount, componentDidUpdate, componentWillUnmount만 커버 가능)
  - props drilling 문제를 해결할 수 있음 : useContext
  - useState의 대안책으로 여러 깊은 트리를 가진 복잡한 상태 로직을 관리하기 용이 : useReducer
  - 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용 가능
  - useState, useEffect 이외에도 다양한 훅 지원
  - 커스텀 hook 정의 가능 : use로 시작하기

- Hook의 장점
  - 더 적은 코드 라인 수 : 라이프사이클별이 아니라 관심사 및 기능별로 그룹화 가능.
  - 복잡한 컴포넌트의 단순화 : 클래스는 관리가 어렵고 핫 리로딩과 함께 사용하기 힘들며, 코드 경량화가 어려울 수 있음
  - 상태 관련 로직 재사용 : 클래스는 여러 단계에 걸친 상속 때문에 전체적인 복잡성을 높이고 에러 발생 가능성을 증가시킬 수 있음
  - UI에서 분리된 로직 공유 : UI와 무관한 로직 추출하고 공유 가능

- Hook의 단점
  - hook 사용 규칙을 준수해야함 : linter 사용하면 도움이 됨
  - 올바르게 사용하려면 상당한 연습 필요
  - 잘못된 사용에 주의해야함 : useCallback, useMemo

- Hook vs Class
  - 클래스 : 고차 컴포넌트, 렌더링 prop 패턴 주로 사용 -> 여러 계층에 걸쳐 앱 구조 파악해야함 / hook : 복잡한 계층 구조 피하고 코드를 더 명확하게 만듦
  - 클래스 : 함수 바인딩, 호출 컨텍스트 이해해야함 / hook : 일관성 부여

## 정적 가져오기
- ES2015+ import 문법
- import 코드에 도달하는 즉시 실행
- 웹팩은 정적으로 가져온 모듈들을 초기 번들에 포함 -> main.bundle.js
- 문제 : 큰 번들은 앱 로딩 시간에 큰 영향을 미침 -> 화면을 보여주기 이전에 모든 모듈을 로드하고 파싱해야 하기 떄문.
- 해결방법 : 상호작용 이후에 동적으로 가져올 수 있음

## 동적 가져오기
- Suspense 사용하는 방법
  - Suspense 사용하여 모듈 가져오기를 일시적으로 중단하고 fallback 컴포넌트를 보여줌.
  - 초기 번들에 포함되지 않고 별도의 번들로 분리하여 초기 번들 크기가 줄어듦.
- 로더블 컴포넌트
  - SSR 환경에서 사용가능한 loadable-components
- 화면에 보이는 순간 가져오는 방법
  - intersectionObserver api, react-loadable-visibilirt, react-lazyload 같은 라이브러리 사용
  - 사용자가 스크롤해야만 화면에 나타나는 컴포넌트들, 이미지 지연 로딩에 주로 사용.