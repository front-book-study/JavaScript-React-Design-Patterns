## 12장. 리액트 디자인 패턴

### 12.2 고차 컴포넌트

고차 컴포넌트패턴은 여러 컴포넌트 동일한 로직을 재사용하는 방법 중 하나

### 12.6 정적 가져오기
- 정적으로 가져오는 모든 모듈은 초기 번들에 추가됩니다.
- ES2015+ 의 기본 import문법은 모두 정적으로 가져온것 
- `import module form 'module'`
- 정적으로 가져왔기 때문에 초기번들에 모두 포함되는데,번들 사이크가 커지면 느린 로딩 유발 


### 12.7 동적 가져오기
- 리액트에선 Suspense를 통해 동적으로 가져옴
- EmojiPicker모듈의 가져오기

### 12.7.1 로더블 컴포넌트 
책 설명 
- SSR 환경은 아직 suspense를 지원하지 않음

추가 설명 : 
- SSR에서는 renderToString을 쓰고,
- CSR에서는 createRoot().render() 

- 동기적으로 동작하므로 
```javascript
import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
```
현재 시점 
- 리액트 18부터 SSR환경에도 suspense를  
- Pages Router에서는 Suspense SSR이 제한적인지

### 12.8 코드 스플리팅 

#### 12.8.1. 경로기반 분할
- 라우트 진입 시 실행되는 동적 import 패턴
- 경로별로 컴포넌트를 지연 로딩하면, 현재 경로에 필요한 코드가 포함된 번들만 요청하게 됨

```javascript

import React, { lazy, Suspense } from 'react';
import { Switch, Route } from 'react-router-dom';


const Home = lazy(
    () => import(/* webpackChunkName: "home" */ './Home')
);
const Channel = lazy(
    () => import(/* webpackChunkName: "channel" */ './Channel')
);
const Threads = lazy(
    () => import(/* webpackChunkName: "threads" */ './Threads')
);
const Contacts = lazy(
    () => import(/* webpackChunkName: "contacts" */ './Contacts')
);

```

#### 12.8.2. 번들러를 이용해 어플리케이션 소스코드 분할 및 번들링

- 요청된 데이터의 로딩 및 실행 시간 최적화는 여전히 개발자의 몱ㅅ 따라서 메인 스레드를 차단하지 않도록 실행시간을 최대한 단축해야함
- 번들크기를 결정할 때 고려해야할 지표
- FCP, LCP, TTI (번들이 실행된 후 부터 인터랙티브까지 걸리는 시간 )
- 초기 로딩 시 현재 페이지에서 우선순위가 노핒 않은 코드를 요청할 땐, 초기 페이지렌더링에 필요한 코드와 분리해서 로드 해야함.

### 12.9 PRPL패턴 

- push : 서버왕복 횟수를 최소화하고 로딩 시간 단축 
- rendering: 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링
- pre-cache : 백그라운드에서 미리 캐싱해 서버 요청 횟수를 줄이고 더 나은 오프라인 경험 제공
- lazy-load: 자주 요청되지 않는 경로나 에셋은 지연 로딩

- HTTP/2는 이전에 보낸 요청이완료되기 전에 동일한 TCP 연결을 통해 여러 요청을 보낼수 있음, HOL blocking문제를 해결
- 서버푸시
  - 서버가 "이 HTML을 보낼 테니 이와 연관된 리소스도 미리 같이 보낼게”라고 클라이언트에게 푸시할 수 있음. (클라이언트가 명시적으로 요청하지 않아도 전송)
- Server Push 단점 
- 캐시 중복, 우선순위 제어 어려움(클라이언트 실제 렌더 우선순위와 충돌 )
- 대안 
  - preload/prefetch 같은 클라이언트 주도 힌트나, 번들러/프레임워크가 자동으로 넣어주는 preload
  
