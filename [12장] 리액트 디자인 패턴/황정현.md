## 12.1.2 리액트 기본 개념

### JSX

XML 과 유사한 구문을 사용하여 HTML을 자바스크립트에서 사용할 수 있게 해주는 확장 문법

### 컴포넌트

리엑트의 기본 구성 요소, 

어떠한 입력값(props)를 받아서 화면에 표시할 내용을 나타내는 리액트의 요소를 반환하는 함수

### Props

리액트 컴포넌트의 내부 데이터 

props 값은 컴포넌트가 만들어지기 전에 미리 결정되고 컴포넌트 설계의 일부로 사용됨

props 값은 바꿀 수 없음, 즉 컴포넌트로 전달되고 나면 읽기 전용이 된다.

### 상태

컴포넌트의 라이프사이클 동안 값이 변할 수도 있는 정보를 담고 있는 객체

### 클라이언트 사이드 렌더링(CSR)

서버가 페이지의 기본 html 컨테이너만을 렌더링, 페이지에 내용을 표시하기 위해 필요한 로직, 데이터 가져오기, 템플릿, 라우팅은 클라이언트에서 실행되는 자바스크립트 코드가 처리

### 서버 사이드 렌더링(SSR)

사용자 요청에 응답하여 페이지 콘텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성

### 동형 렌더링

클라이언트와 서버 모두에서 동일한 코드로 렌더링 할 수 있는 기술

### 하이드레이션

서버에서 렌더링 된 애플리케이션에서 현재 페이지의 html 이 서버에서 생서오디어 클라이언트로 전송

서버에서 이미 마크업을 생성했기 때문에 클라이언트는 이를 빠르게 파싱하여 화면에 나타낼 수 잇음.

UI를 상호작용할 수 있게 하는 이벤트 핸들러는 자바스크립트 번들이 로드되고 처리된 후에 비로소 연결되는 과정

## 12. 2 고차 컴포넌트 (HOC)

```jsx
function withStyles(Component) {
  return props => {
    const style = { padding: '0.2rem', margin: '1rem' }
    return <Component style={style} {...props} />
  }
}

const Button = () = <button style={{ color: 'red' }}>Click me!</button>
const StyledButton = withStyles(Button)
```

여러 컴포넌트에서 동일한 로직을 재사용하는 방법 중 하나

다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트

### 고차 컴포넌트가 효과적인 경우

- 애플리케이션 전체에 걸쳐 여러 컴포넌트에 동일한 로직을 적용해야하 ㄹ때
- 추가된 커스텀 로직 없이도 컴포넌트가 독립적으로 작동할 수 있을 때

### 단점

- 고차 컴포넌트가 대상 컴포넌트에 전달하는 prop의 이름이 충돌을 일으킬 수 잇음
    
    ```jsx
    function withStyles(Component) {
      return props => {
        const style = { padding: '0.2rem', margin: '1rem', ***...props.style*** }  // 충돌을 처리할 수 있도록 병합 방식 사용
        return <Component style={style} {...props} />
      }
    }
    
    const Button = () = <button style={{ color: 'red' }}>Click me!</button>
    const StyledButton = withStyles(Button)
    ```
    
- 여러 고차 컴포넌트를 조합해서 사용한다면 어떤 고차 컴포넌트가 어떤 props 를 제공하는지 파악하기 어려울 수 있음


## 12.3 렌더링 props 패턴

JSX 요소를 반환하는 함수 값을 가지는 컴포넌트의 prop 

```jsx
<Title render=(()=> <h1>im render porp</h1>)
```

상태 끌어올리기를 사용할 떄 복잡해질 수 있는 문제를 해결함

더군더나 상태의 변경은 모든 자식 컴포넌트의 리렌더링을 유발할 수 있고 이런 상황이 쌓이면 앱의 전체적인 성능을 떨어트릴 수 있는 문제를 해결할 수 있다

```jsx
function Input(props) {
  const [value, setValue] = useState("");

  return (
    <>
      <input value={value} onChange={(e) => setValue(e.target.value)} />
      {props.renderKelvin({ value: value + 273.15 })}
      {props.renderFahrenheit({ value: (value * 9) / 5 + 32 })}
    </>
  );
}

export default function App() {
  return (
    <Input
      renderKelvin={({ value }) => <div className="temp">{value}K</div>}
      renderFahrenheit={({ value }) => <div className="temp">{value}°F</div>}
    />
  );
}
```

### 단점

라이프사이클 메서드를 사용할 수 없음.

받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트만 사용해야함


### 클래스 컴포넌트의 단점

- 핫 리로딩(HMR 과 함께 사용하기 어려움
- 코드 경량화가 어려움

## 12.7 동적 가져오기

정적 가져오기의 문제 

- 초기 번들이 불필요하게 추가됨
    - 버튼을 클릭해야 렌더링 되는 컴포넌트를 미리 가져오는 것 등..
- 잠재적인 초기 로딩시간이 증가할 수 있는 문제점이 존재

### 리엑트에서 사용법

```jsx
import React, { Suspense, lazy } from 'react';

// 1. 선언: "이건 나중에 로드될 컴포넌트야"라고 정의만 함
const MyComponent = lazy(() => import('./MyComponent'));

const App = () => {
  return (
    // 2. 위임: 로딩 중 상태(UI)는 Suspense에게 맡김
    <Suspense fallback={<div>Loading...</div>}>
      <MyComponent />
    </Suspense>
  );
};
```

## 12.8 번들 분할

거대한 번들 하나를 요청하는 대신, 번들 을 여러 개의 작은 번들로 분할하는 방법을 사용할 수 있음

개선 방법

- 사용자 화면에 표시되는 시간(FCP) 단축
- 가장 큰 콘텐츠가 화면에 렌더링되는 시간(LCP) 개선
- 모든 콘텐츠가 화면에 표시되고 인터랙티브해지는 데 걸리는 시간(TTI) 개선

## 12.9 PRPL 패턴

저사양 기기나 인터넷 연결이 불안정한 지역에서도 애플리케이션이 원활하게 작동하게 하는 방법 중 하나

### PRPL 패턴은 다음 네 가지 핵심 성능 고려사항에 중점을 둠

- **푸시 (Push)**
    - 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축
- **렌더링 (Rendering)**
    - 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더
- **사전 캐싱 (Pre-cache)**
    - 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄여 더 나은 오프라인 경험 제공
- **지연 로딩 (Lazy-load)**
    - 자주 요청되지 않는 경로나 에셋은 지연 로딩

## 12.10 로딩 우선순위

필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정

### 주의사항

- 상호작용에 필요한 리소스를 먼저 로딩하다가 FCP 또는 LCP에 필요한 리소스의 로딩이 지연되는 일은 피해야함
- 만약 자바스크립트 자체의 로딩을 최적화하려면, body 태그보다는 head 태그 안에서 scrept defer을 사용하는 것이 해당 리소스를 초기에 로딩하는 데 도움이 될 수 있음
