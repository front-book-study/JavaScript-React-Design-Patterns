
## Smalltalk-80’s MVC
- 최초의 MVC 패턴
- observer pattern이 뷰에서 모델을 관찰하기 위한 용도로 사용됨

## MVC for JavaScript Developers
- MVC는 JavaScript에서도 Backbone, Ember.js, AngularJS 같은 초기 프레임워크와, React, Angular, Vue.js 같은 최신 생태계에서 다양한 MV* 변형으로 사용된다.
- 목적은 스파게티 코드(구조 부족으로 읽기/유지보수 어려운 코드)를 피하기 위한 구조 제공이다.

### Models
- 비즈니스 데이터와 관련
- Models는 애플리케이션의 데이터를 관리하며, UI나 프레젠테이션에는 관여하지 않는다.
- Model이 변경되면 **옵저버(보통 View)**에게 변경 사실을 알린다.
- 예: 사진 갤러리에서 Photo는 Model로 표현되며 caption, image source 등 속성을 가질 수 있다.
- Models는 보통 속성(validations) 및 **영속성(persistence)**을 제공한다.
- 한 Model은 여러 View가 관찰할 수 있다.
- Model은 Collection으로 그룹화될 수 있고, 그룹 내 Model 변경에 기반해 로직을 작성할 수 있다.
- 오래된 MVC에서는 Model이 애플리케이션 “state”를 관리한다고 했으나, JavaScript의 state는 SPA에서 화면의 현재 상태를 의미하는 다른 개념이다.

## View

- 뷰는 모델의 시각적 표현
- 뷰는 일반적으로 모델을 관찰하고 모델이 변경되면 알림을 받아 그에 따라 스스로 업데이트합니다
- 모델을 업데이트하는 실제 작업은 컨트롤러의 몫

```javascript
const buildPhotoView = (photoModel, photoController) => {
  const base = document.createElement( "div" );
  const photoEl = document.createElement( "div" );

  base.appendChild(photoEl);

  const render = () => {
        // We use Lodash's template method
        // which generates the HTML for our photo entry
        photo entry
        photoEl.innerHTML = _.template("#photoTemplate", {
            src: photoModel.getSrc()
        });
    };

  // View(구독자)가 Model을 구독(모델의 변경을 관찰)
    // Model은 등록된 subscriber(=render)를 모두 호출
  photoModel.addSubscriber( render );
  
  // 컨트롤러를 통해 모델 업데이트
  photoEl.addEventListener( "click", () => {
    photoController.handleEvent( "click", photoModel );
  });
};

```

## MVP
- 모델-뷰-프레젠터(MVP)는 파생형
- 프레젠테이션 로직 개선에 중점을 둔 MVC 디자인 패턴의 한 유형
- MVC와 달리, 뷰에서의 호출은 프리젠터로 위임됨.
- P는 모델을 관찰하고 모델이 변경되면 뷰를 업데이트합니다.
- P는 MVC에서 컨트롤러의 역할인 모델을 뷰에 효과적으로 연결합니다.
- MVP에서는 View가 인터페이스로 정의되기 때문에 실제 UI가 완성되기 전에 Presenter 로직을 먼저 개발할 수 있다
  (실제 UI 없이도 MockView 만들어서 Presenter 테스트 가능)



## MVVM(Model-View-ViewModel)
- MVC와 MVP 기반 아키텍처 패턴은 UI 개발을 애플리케이션의 비즈니스 로직 및 동작과 더욱 명확하게 분리하고자 함
- 이를 위해 선언적 데이터 바인딩을 사용해 뷰 작업을 다른 계층과 분리
- 동일한 코드베이스 내에서 UI 작업과 개발 작업을 거의 동시에 수행
- UI 개발자는 문서 마크업(HTML) 내에서 ViewModel에 대한 바인딩 작성
- 애플리케이션 로직을 작업하는 개발자는 Model과 ViewModel 관리


## 정리

MVC / MVP / MVVM은 겉으로 보면 비슷해 보이지만
1. View와 로직이 서로를 얼마나 아는가와
2. 상태를 어떻게 흐르게 하느냐에서 본질적 차이가 생긴다.

MVC는 View → Controller 의존성이 있다. 동시에 뷰는 모델에 직접 접근할 수 있음.
하지만 전체 모델을 뷰에 노출하면 애플 애플리케이션의 복잡성에 따라 보안 및 성능 저하

MVP의 View는 Presenter만 알고 있고 Model은 모른다(결합도 낮음).Presenter가 모든 조율을 담당한다
Presenter는 View 인터페이스만 알고, 실제 UI 구현을 모른다. View를 인터페이스로 분리해 Presenter와 화면 구현을 완전히 분리
하기 때문에 1. UI 없이도 Presenter 단독 개발 가능하고 2. UI 바뀌어도 Presenter 수정 없음 3. 단위 테스트 매우 쉬움 (MockView 사용)

MVVM에서는 View를 완전히 격리 시킬수있다.
MVP에서 P는 View를 인터페이스 수준으로 알지만, VM에서는 그 조차도 모른다.
그럼 어떻게 데이터를 주고 받을까? ViewModel에서 모두 관할하고 view가 VM을 구독함으로써
VM에서 상태가 변경되면 자동으로 감지하고 반응.



