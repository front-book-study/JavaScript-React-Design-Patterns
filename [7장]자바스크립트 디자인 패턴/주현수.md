## 7.3 모듈패턴
- 클로저를 활용해 코드의 캡슐화(encapsulation)와 의존성 관리를 해결하기 위한 패턴

1. 모듈 패턴이 생겨난 배경
   ES6 이전(즉, import/export가 없던 시절)의 자바스크립트는 전역 오염(global pollution)
  
즉, 즉시실행함수(IIFE)로 스코프를 하나 만들고,
그 안에 상태와 함수를 숨겨놓은 뒤,
오직 필요한 부분만 객체 형태로 반환(export) 하는 방식 

모듈패턴예제 (책에 없는 예제 )
```javascript
const Counter = (function() {
  // private (module scope)
  let count = 0;

  function changeBy(n) { count += n; }

  return {
    increment() { changeBy(1); },
    value() { return count; }
  };
})();

Counter.increment();
console.log(Counter.value()); // 1
// 외부에서 count에 직접 접근 불가
```

클로저가 있어도 반환한 객체에 내부 객체(예: 배열/객체)를 그대로 포함시키면 외부에서 그 참조를 통해 내부 상태 변경

```javascript
const BadMod = (function() {
  const data = { secret: 42 };
  return {
    getData() { return data; } // 내부 객체 참조를 그대로 반환
  };
})();

const d = BadMod.getData();
d.secret = 100; // 내부 상태 변경 가능 — 캡슐화 실패
```

weakMap사용을 통해 인스턴스별 비공개
```javascript
const _private = new WeakMap();

class Person {
  constructor(name, age) {
    _private.set(this, { name, age });
  }

  getName() {
    return _private.get(this).name;
  }

  setAge(a) {
    _private.get(this).age = a;
  }
}

const p = new Person('현수', 30);
console.log(p.getName()); // '현수'
// 외부에서 _private에 접근 불가(스코프 내부에 숨김)
```


2. ES6 이후의 진화
   문법적으로는 다르지만, 개념적으로는 동일
   즉, 모듈 패턴의 철학(캡슐화 + 명확한 인터페이스)을 언어 차원에서 공식화한 형태


## 7.5 싱글톤 패턴

> “하나의 클래스(또는 객체 인스턴스)가 오직 한 번만 생성되도록 보장한다.”

- 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있다. 인스턴스 생성을 지연시킬 수 있다.
- 초기화 시점에 필요한 정보가 유효하지 않을 수 있으므로 싱글톤 패턴을 통해 초기화를 미루면 안전하게 인스턴스를 만들 수 있다.
- 그리고 필요할 때까지는 리소스나 메모리를 소모하지 않도록 지연생성할 수 있다.
- 싱글톤은 객체나 클래스가 아닌 구조이다-> 개인적으로 중요하다고 생각하는 부분


단점
- 싱글톤임을 파악하는것이 힘들다
- 테스트 어려움(숨겨진 의존성, 여러 인스턴스생성의 어려움, 의존성 대체의 어려움 )
- 생성 시점과 사용 시점을 조정해야 한다. 전역에서 하나의 인스턴스를 공유하므로 여러 컴포넌트가 동시에 접근할 때 인스턴스가 유효하지 않은 상태면 문제가 생기기 때문.


## 7.6 프로토타입 패턴
- GoF : 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
- JS만의 특성(프로토타입 기반 상속)을 활용하면 다른 언어의 클래스 중심 설계에 맞추지 않고도 객체지향적 설계와 패턴을 구현할 수 있음

- JS에서 프로토타입 상속 구현 예제
```javascript
       const carPrototype = {
  name: "Ford Escort",
  drive() {
    console.log("Weeee. I'm driving!");
  },
  panic() {
    console.log("Wait. How do you stop this thing?");
  },
};

const justCar = carPrototype;
justCar.name = "just carname";
console.log(
  "justCar name:",
  justCar.name,
  "yourcar name:",
  carPrototype.name //justCar.name속성이 변경됨
);
console.log("====================================");
const yourcar = Object.create(carPrototype);
yourcar.name = "your carname";
console.log(
  "yourcar name:",
  yourcar.name,
  "carPrototype name:",
  carPrototype.name // Ford Escort 로 carPrototype.name속성이 변경되지 않음.
);

```


- create의 문제점은 객체의 속성을 나열할 때 상속된 속성만 나열될 수 있으므로, hasOwnProperty() 로 속성체크
- create가 아닌 ES6의 클래스를 이용한 프로토타입 패턴
- 해당 방식의 주의사항 : Prototype 객체가 공유되므로 변경 시 다른 객체에 영향 가능
- 이에 대한 대응 : `Object.defineProperty` 읽기전용 속성 만들기, getter만 제공
-
```javascript
     class VehiclePrototype {
        constructor(model) {
          this.model = model;
        }

        getModel() {
          console.log(`The model of this vehicle is... ${this.model}`);
        }

        clone() {}
      }

      class Vehicle extends VehiclePrototype {
        constructor(model) {
          super(model);
        }

        clone() {
          return new Vehicle(this.model);
        }
      }

      const car = new Vehicle("Ford Escort");
      const myCar = car.clone();
      console.log("myCar shared:", myCar.shared);
      myCar.getModel();
      console.log("myCar model:", myCar.model);
      console.log("car model:", car.model);

      console.log("====================================");

      VehiclePrototype.prototype.model = "hello";
      console.log("vehicle.prototype model:", VehiclePrototype.prototype.model); //vehicle.prototype model: hello

      console.log("car model:", car.model); // car model: Ford Escort
      console.log("myCar model:", myCar.model); //myCar model: Ford Escort
      console.log("====================================");
```


## 7.7 팩토리패턴
- 객체를 생성하는 생성 패턴의 하나인데, 생성자를 필요로하지 않는다.
- 클라이언트가 어떻게 구체적인 클래스를 이용해 생성하는 방법을 몰라도 팩토리가 알아서 생성해주는 구조


```javascript
    class Car {
      constructor({ doors = 4, state = 'brand new', color = 'silver' } = {}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
      }
    }

    class Truck {
      constructor({ state = 'used', wheelSize = 'large', color = 'blue' } = {}) {
        this.state = state;
        this.wheelSize = wheelSize;
        this.color = color;
      }
    }

    class VehicleFactory {
      constructor() {
        this.vehicleClass = Car;
      }

      createVehicle(options) {
        const { vehicleType, ...rest } = options;

        switch (vehicleType) {
          case 'car':
            this.vehicleClass = Car;
            break;
          case 'truck':
            this.vehicleClass = Truck;
            break;
          // defaults to VehicleFactory.prototype.vehicleClass (Car)
        }

        return new this.vehicleClass(rest);
      }
    }
```

#### 팩토리 클래스를 통해 제품을 만드는 방법

1. 팩토리 클래스의 인스턴스 수정
```javascript
 const truck = vehicleFactory.createVehicle({
        vehicleType: 'truck',
        color: 'red',
        wheelSize: 'medium',
      });
```


2. 팩토리 클래스를 서브클래스해 특정 프러덕트를 담당하는 팩토리 생성
```javascript
    class TruckFactory extends VehicleFactory {
        constructor() {
          super();
          this.vehicleClass = Truck;
        }
      }


// Create an instance of our truck factory
const truckFactory = new TruckFactory();
// Create a truck using the truck factory
const movingTruck = truckFactory.createVehicle({
  state: 'like new',
  color: 'red',
  wheelSize: 'small',
});

// Test to confirm our truck was created with the vehicleClass/prototype Truck
// Outputs: true
console.log(movingTruck instanceof Truck);

```

주의할점
- 팩토리패턴은 객체 생성과정을 인터페이스 뒤에 추상화하므로 객체생성과정이 복잡할경우 단위테스트 복잡성 증가
- 객체생성 인터페이스 제공이 작업중인 라이브러리나 프레임워크 설계목표가 아니라면 차라리 위험을 피해 생성자를 사용하는것이 좋다.


#### 추상팩토리 패턴
- 객체의 생성과정에서 영향을 받지 않아야 하거나, 여러타입의 객체로 작업해야 하는경우에 추상팩토리를 사용하면 좋다.
- 객체를 생성하는 메서드의 규약(인터페이스)만 정의, 어떤 종류의 Vehicle을 만들지는 모름
- 해당 예제에서는 register를 통해 구체 팩토리 대신.

```typescript
      // AbstractVehicleFactory.js
      class AbstractVehicleFactory {
        constructor() {
          // Storage for our vehicle types
          this.types = {};
        }

        getVehicle(type, customizations) {
          const Vehicle = this.types[type];
          return Vehicle ? new Vehicle(customizations) : null;
        }

        registerVehicle(type, Vehicle) {
          const proto = Vehicle.prototype;
          // only register classes that fulfill the vehicle contract
          if (proto.drive && proto.breakDown) {
            this.types[type] = Vehicle;
          }
          return this;
        }
      }

      // Create an instance of the AbstractVehicleFactory
      const abstractVehicleFactory = new AbstractVehicleFactory();

      // Register car class with the factory
      abstractVehicleFactory.registerVehicle('car', Car); //Car서브팩토리 필요 없음

      // Register truck class with the factory
      abstractVehicleFactory.registerVehicle('truck', Truck); //Truck서브 팩토리 필요없음

    const truck = abstractVehicleFactory.getVehicle('truck', {
        wheelSize: 'medium',
        color: 'neon yellow',
    });

    const car = abstractVehicleFactory.getVehicle('car', {
        color: 'lime green',
        state: 'like new',
    });
```

