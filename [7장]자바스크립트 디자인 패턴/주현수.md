## 7.3 모듈패턴
- 클로저를 활용해 코드의 캡슐화(encapsulation)와 의존성 관리를 해결하기 위한 패턴

1. 모듈 패턴이 생겨난 배경
   ES6 이전(즉, import/export가 없던 시절)의 자바스크립트는 전역 오염(global pollution)
  
즉, 즉시실행함수(IIFE)로 스코프를 하나 만들고,
그 안에 상태와 함수를 숨겨놓은 뒤,
오직 필요한 부분만 객체 형태로 반환(export) 하는 방식 

모듈패턴예제 (책에 없는 예제 )
```javascript
const Counter = (function() {
  // private (module scope)
  let count = 0;

  function changeBy(n) { count += n; }

  return {
    increment() { changeBy(1); },
    value() { return count; }
  };
})();

Counter.increment();
console.log(Counter.value()); // 1
// 외부에서 count에 직접 접근 불가
```

클로저가 있어도 반환한 객체에 내부 객체(예: 배열/객체)를 그대로 포함시키면 외부에서 그 참조를 통해 내부 상태 변경

```javascript
const BadMod = (function() {
  const data = { secret: 42 };
  return {
    getData() { return data; } // 내부 객체 참조를 그대로 반환
  };
})();

const d = BadMod.getData();
d.secret = 100; // 내부 상태 변경 가능 — 캡슐화 실패
```

weakMap사용을 통해 인스턴스별 비공개
```javascript
const _private = new WeakMap();

class Person {
  constructor(name, age) {
    _private.set(this, { name, age });
  }

  getName() {
    return _private.get(this).name;
  }

  setAge(a) {
    _private.get(this).age = a;
  }
}

const p = new Person('현수', 30);
console.log(p.getName()); // '현수'
// 외부에서 _private에 접근 불가(스코프 내부에 숨김)
```


2. ES6 이후의 진화
   문법적으로는 다르지만, 개념적으로는 동일
   즉, 모듈 패턴의 철학(캡슐화 + 명확한 인터페이스)을 언어 차원에서 공식화한 형태


## 7.5 싱글톤 패턴

> “하나의 클래스(또는 객체 인스턴스)가 오직 한 번만 생성되도록 보장한다.”

- 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있다. 인스턴스 생성을 지연시킬 수 있다.
- 초기화 시점에 필요한 정보가 유효하지 않을 수 있으므로 싱글톤 패턴을 통해 초기화를 미루면 안전하게 인스턴스를 만들 수 있다.
- 그리고 필요할 때까지는 리소스나 메모리를 소모하지 않도록 지연생성할 수 있다.
- 싱글톤은 객체나 클래스가 아닌 구조이다-> 개인적으로 중요하다고 생각하는 부분


단점
- 싱글톤임을 파악하는것이 힘들다
- 테스트 어려움(숨겨진 의존성, 여러 인스턴스생성의 어려움, 의존성 대체의 어려움 )
- 생성 시점과 사용 시점을 조정해야 한다. 전역에서 하나의 인스턴스를 공유하므로 여러 컴포넌트가 동시에 접근할 때 인스턴스가 유효하지 않은 상태면 문제가 생기기 때문.


## 7.6 프로토타입 패턴
- GoF : 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
- JS만의 특성(프로토타입 기반 상속)을 활용하면 다른 언어의 클래스 중심 설계에 맞추지 않고도 객체지향적 설계와 패턴을 구현할 수 있음

- JS에서 프로토타입 상속 구현 예제
```javascript
       const carPrototype = {
  name: "Ford Escort",
  drive() {
    console.log("Weeee. I'm driving!");
  },
  panic() {
    console.log("Wait. How do you stop this thing?");
  },
};

const justCar = carPrototype;
justCar.name = "just carname";
console.log(
  "justCar name:",
  justCar.name,
  "yourcar name:",
  carPrototype.name //justCar.name속성이 변경됨
);
console.log("====================================");
const yourcar = Object.create(carPrototype);
yourcar.name = "your carname";
console.log(
  "yourcar name:",
  yourcar.name,
  "carPrototype name:",
  carPrototype.name // Ford Escort 로 carPrototype.name속성이 변경되지 않음.
);

```


- create의 문제점은 객체의 속성을 나열할 때 상속된 속성만 나열될 수 있으므로, hasOwnProperty() 로 속성체크
- create가 아닌 ES6의 클래스를 이용한 프로토타입 패턴
- 해당 방식의 주의사항 : Prototype 객체가 공유되므로 변경 시 다른 객체에 영향 가능
- 이에 대한 대응 : `Object.defineProperty` 읽기전용 속성 만들기, getter만 제공
-
```javascript
     class VehiclePrototype {
        constructor(model) {
          this.model = model;
        }

        getModel() {
          console.log(`The model of this vehicle is... ${this.model}`);
        }

        clone() {}
      }

      class Vehicle extends VehiclePrototype {
        constructor(model) {
          super(model);
        }

        clone() {
          return new Vehicle(this.model);
        }
      }

      const car = new Vehicle("Ford Escort");
      const myCar = car.clone();
      console.log("myCar shared:", myCar.shared);
      myCar.getModel();
      console.log("myCar model:", myCar.model);
      console.log("car model:", car.model);

      console.log("====================================");

      VehiclePrototype.prototype.model = "hello";
      console.log("vehicle.prototype model:", VehiclePrototype.prototype.model); //vehicle.prototype model: hello

      console.log("car model:", car.model); // car model: Ford Escort
      console.log("myCar model:", myCar.model); //myCar model: Ford Escort
      console.log("====================================");
```


## 7.7 팩토리패턴
- 객체를 생성하는 생성 패턴의 하나인데, 생성자를 필요로하지 않는다.
- 클라이언트가 어떻게 구체적인 클래스를 이용해 생성하는 방법을 몰라도 팩토리가 알아서 생성해주는 구조


```javascript
    class Car {
      constructor({ doors = 4, state = 'brand new', color = 'silver' } = {}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
      }
    }

    class Truck {
      constructor({ state = 'used', wheelSize = 'large', color = 'blue' } = {}) {
        this.state = state;
        this.wheelSize = wheelSize;
        this.color = color;
      }
    }

    class VehicleFactory {
      constructor() {
        this.vehicleClass = Car;
      }

      createVehicle(options) {
        const { vehicleType, ...rest } = options;

        switch (vehicleType) {
          case 'car':
            this.vehicleClass = Car;
            break;
          case 'truck':
            this.vehicleClass = Truck;
            break;
          // defaults to VehicleFactory.prototype.vehicleClass (Car)
        }

        return new this.vehicleClass(rest);
      }
    }
```

#### 팩토리 클래스를 통해 제품을 만드는 방법

1. 팩토리 클래스의 인스턴스 수정
```javascript
 const truck = vehicleFactory.createVehicle({
        vehicleType: 'truck',
        color: 'red',
        wheelSize: 'medium',
      });
```


2. 팩토리 클래스를 서브클래스해 특정 프러덕트를 담당하는 팩토리 생성
```javascript
    class TruckFactory extends VehicleFactory {
        constructor() {
          super();
          this.vehicleClass = Truck;
        }
      }


// Create an instance of our truck factory
const truckFactory = new TruckFactory();
// Create a truck using the truck factory
const movingTruck = truckFactory.createVehicle({
  state: 'like new',
  color: 'red',
  wheelSize: 'small',
});

// Test to confirm our truck was created with the vehicleClass/prototype Truck
// Outputs: true
console.log(movingTruck instanceof Truck);

```

주의할점
- 팩토리패턴은 객체 생성과정을 인터페이스 뒤에 추상화하므로 객체생성과정이 복잡할경우 단위테스트 복잡성 증가
- 객체생성 인터페이스 제공이 작업중인 라이브러리나 프레임워크 설계목표가 아니라면 차라리 위험을 피해 생성자를 사용하는것이 좋다.


#### 추상팩토리 패턴
- 객체의 생성과정에서 영향을 받지 않아야 하거나, 여러타입의 객체로 작업해야 하는경우에 추상팩토리를 사용하면 좋다.
- 객체를 생성하는 메서드의 규약(인터페이스)만 정의, 어떤 종류의 Vehicle을 만들지는 모름
- 해당 예제에서는 register를 통해 구체 팩토리 대신.

```typescript
      // AbstractVehicleFactory.js
      class AbstractVehicleFactory {
        constructor() {
          // Storage for our vehicle types
          this.types = {};
        }

        getVehicle(type, customizations) {
          const Vehicle = this.types[type];
          return Vehicle ? new Vehicle(customizations) : null;
        }

        registerVehicle(type, Vehicle) {
          const proto = Vehicle.prototype;
          // only register classes that fulfill the vehicle contract
          if (proto.drive && proto.breakDown) {
            this.types[type] = Vehicle;
          }
          return this;
        }
      }

      // Create an instance of the AbstractVehicleFactory
      const abstractVehicleFactory = new AbstractVehicleFactory();

      // Register car class with the factory
      abstractVehicleFactory.registerVehicle('car', Car); //Car서브팩토리 필요 없음

      // Register truck class with the factory
      abstractVehicleFactory.registerVehicle('truck', Truck); //Truck서브 팩토리 필요없음

    const truck = abstractVehicleFactory.getVehicle('truck', {
        wheelSize: 'medium',
        color: 'neon yellow',
    });

    const car = abstractVehicleFactory.getVehicle('car', {
        color: 'lime green',
        state: 'like new',
    });
```

해당 패턴들은 구조 패턴의 범주에 속하므로 클래스와 개체를 더 큰 구조로 만들수 있게 하는 목적성을 염두하기

## 7.11 Facade

> 퍼사드 패턴은 심층적인 복잡성을 숨기고, 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴

- jQuery나 자바스크립트 라이브러리에서 흔히 볼 수 있는 구조 패턴
- 숨겨진 하위 시스템이 아닌, 밖에 나타난 퍼사드와 직접 상호작용 가능
- 예를 들어, jQuery의 $(el).css, $(el).animate() 같은 메서드 사용시 퍼사드를 사용하는것
- 퍼사드로 만들어진 시스템에 의해 main 에서 실행되는 클라이언트는 서브시스템 클래스들 각각의 내부 구현에 대해 자세히 알필요가 없다
- 서브시스템의 사용법이 변경되더라도 클라이언트 코드가 아닌 퍼사드 코드만 맞춰 수정하면된다(?)

### 느낀점

- `Facade는 "조율자"로, 실제 일은 서브시스템으로`
- Facade 패턴은 이미 잘 설계된 서브시스템들 위에 단순한 인터페이스를 제공하는 것이라고 생각함

## 7.12 Mixin

- 기능의 확장을 위해 믹스인의 상속을 이용
- 동적으로 부모 클래스를 받아 확장하는 Mixins함수 만들기

```javascript
const MyMixins = superclass => class extends superclass{
  moveup(){
    console.log("move up")
  }
  moveDown(){
    console.log("move down")
  }
  stop(){
    console.log("stop! in the name of love!")
  }
}
```

CarAnimatior, PersonAnimator = MyMixin을 사용해 기존 클래스의 기능 +추가기능

```javascript
class CarAnimator{
  moveleft(){
    console.log("move left")
  }
}
class PersonAnimator{
  moveRandomly(){
    /***.... */
  }
}
class MyAnimator extends MyMixin(CarAnimator){}
const myAnimator = new myAnimator()
myAnimator.moveleft()
```

- 반복된 기능을 줄이고, 새로운 기능을 확장 할 수 있음

### 믹스인패턴의 논쟁

- 프로토 타입 오염과 함수출처에 대한 불확실성
- 리액트 es6 클래스 도입 이전, 컴포넌트에 기능추가하기 위해 믹스인 사용
- 유지보수와 재사용 복잡서으로 믹스인 반대
- 고차 컴포넌트나 Hooks장려

## 7.13 데코레이터 패턴

- 객체에 동적으로 새로운 기능을 추가하는 패턴
- 기존 코드를 수정하지 않고 기능 확장
- 상속 대신 조합(Composition) 사용

```javascript
// 사용법
const myMacbookPro = new MacbookPro()
//맥북에 케이스 데코레이터 추가
const decorateMacbookPro = new CaseDecorator(myMacbookPro)
```

### 주의사항

- 자잘한 객체가 많이 추가 되므로, 복잡도가 높아짐
- 협업시 패턴에 익숙하지 않은 개발자가 사용목적을 파악하기 어려워 관리가 힘들어짐

### 느낀점

- 데코레이터를 생각하면 어떤 몸체가 있고 거기에 꾸며주는 역할 → 기능을 확장
- 이 때 몸체는 그대로(기존코드 수정없이)
- 그럼 같은 원리로 컴포넌트를 생각해보면, 몸체 컴포넌트가 있고 컴포넌트를 받아 기능을 확장하는 새로운 컴포넌트를 리턴한다
- 리액트 컴포넌트에선 Higher Order Component 같은 원리, Higher Order Function - 자바스크립트

## 플라이웨이트 패턴

- 반복되고 비효율적으로 데이터를 공유하는 코드를 최적화
- 연관된 객체끼리 데이터를 공유하면서 어플리케이션의 메모리를 최소화하는 목적

### 사용법

- 데이터 레이어에서 메모리에 저장된 비슷한 객체사이로 데이터 공유
- DOM레이어에서 비슷한 동작을 하는 이벤트 핸들러를 부모 요소같은 중앙 이벤트 관리자에게 위임

### 플라이워이트 패턴과 DOM객체

- 이벤트 감지 방법 : 이벤트 캡처링, 버블링
- 캡처링은 이벤트가 상위요소에서 감지되어 → 하위요소로 전파
- 버블링은 이벤트가 하위요소에서 감지되어 → 상위요소로 전파
- 여기서 플라이웨이트는 이벤트 버블링 과정을 추가조정하는데 사용
- 반복되는 이벤트 핸들러를 상위 요소에 위임


## 7.18 관찰자 패턴

![observer](https://www.oreilly.com/api/v2/epubs/urn:orm:book:9781449334840/files/httpatomoreillycomsourceoreillyimages1547801.png)

- 여러 요소들간의 결합도를 낮추는데 유용한 패턴
- 주체의 상태가 변화하면 관찰하는 여러 옵저버에게 자동으로 알림을 보냄
- 옵저버는 주체에게 등록을 해야한다( 결합관계) → **발행/구독 패턴보다 더 묶여 있는 형태**


```javascript
// ObserverList class
class ObserverList {
  constructor() {
    this.observerList = [];
  }

  add(obj) {
    return this.observerList.push(obj);
  }

  count() {
    return this.observerList.length;
  }

  get(index) {
    if (index > -1 && index < this.observerList.length) {
      return this.observerList[index];
    }
  }

  indexOf(obj, startIndex) {
    let i = startIndex;

    while (i < this.observerList.length) {
      if (this.observerList[i] === obj) {
        return i;
      }
      i++;
    }

    return -1;
  }

  removeAt(index) {
    this.observerList.splice(index, 1);
  }
}
//=====================================================================
// Subject class
class Subject {
  constructor() {
    this.observers = new ObserverList();
  }

  addObserver(observer) {
    this.observers.add(observer);
  }

  removeObserver(observer) {
    this.observers.removeAt(
      this.observers.indexOf(observer, 0)
    );
  }

  notify(context) {
    const observerCount = this.observers.count();
    for (let i = 0; i < observerCount; i++) {
      this.observers.get(i).update(context);
    }
  }
}
//=====================================================================
// Observer class
class Observer {
  constructor() {}

  update() {
    // ...
  }
}

// ConcreteSubject class
class ConcreteSubject extends Subject {
  constructor(element) {
    super();
    this.element = element;

    this.element.onclick = () => {
      this.notify(this.element.checked);
    };
  }
}
//=====================================================================
// ConcreteObserver class
class ConcreteObserver extends Observer {
  constructor(element) {
    super();
    this.element = element;
  }

  update(value) {
    this.element.checked = value;
  }
}

// Get references to DOM elements
const addBtn = document.getElementById('addNewObserver');
const container = document.getElementById('observersContainer');
const countBtn = document.getElementById('countObservers');
const removeBtn = document.getElementById('removeObservers');
const observerCountElem = document.getElementById('observerCount');
const mainCheckbox = document.getElementById('mainCheckbox');

const controlCheckbox = new ConcreteSubject(mainCheckbox);
let observerCount = 0;

const addNewObserver = () => {
  const check = document.createElement('input');
  check.type = 'checkbox';
  check.classList.add('observer');
  const checkObserver = new ConcreteObserver(check);

  controlCheckbox.addObserver(checkObserver);

  container.appendChild(check);
  observerCount++;
  updateObserverCount();
};

const countObservers = () => {
  observerCountElem.textContent = `Observer Count: ${observerCount}`;
};


const updateObserverCount = () => {
  observerCountElem.textContent = `Observer Count: ${observerCount}`;
};

addBtn.onclick = addNewObserver;
countBtn.onclick = countObservers;
removeBtn.onclick = removeObservers;
```

## 발행/구독 패턴 구현

- ECMAScript의 구현제가 이벤트 기반이므로JS생태계와 잘 어울림
- ex) 이벤트 기반 구조의 DOM API

구현예제

```tsx
class PubSub{
	constructor(){
		this.topics={}
		
		this.subUid= -1
		
	}
	
	public(topic, args){
		if(!this.topics[topic]){
			return false
		
		}
		const subscribers = this.topics[topic]
		let len = subscribers? subscribers.length: 0
		
		while(len--){
			subscribers[len].func(topics,args);
		}
		
		return this;
		
	
	}
	
	subscribe(topic, func){
		if(!this.topics[topic]){
			this.topics[topic] = []
		}
		
		const token = (++this.subUid).toString()
		this.topics[topic].push({token, func})
	}
	return token

}
```

위의 pub/sub구현체를 통해 이벤트를 발행하고 구독

```tsx
const subscription = pubsub.subscribe("index/newMessage", messageLogger)

const messageLogger = (topics, data)=>{
	console.log(`${topics}:${data}`)
}

pubsub.publish('inbox/newMessage', 'helloWorld')

```

### 관찰자 패턴과 구독패턴의 차이

- 관찰자 패턴에서는 observer와 subscriber 간의 결합도가 있다.
- 하지만, 구독패턴에서는 토픽/이벤트 채널을 통해 이둘의 결합도를 느슨하게 만들어 독립적으로 유지할 수 있다.

### pub/sub 결합도 낮추기

요청에 대한 응답 콜백 로직엔  여러 역할(데이터 처리 + UI 갱신 + 로그 등)을 하는 높은 결합도를 가지는 코드를 정의하는 경우들이 있다.

문제점 :  그 기능을 다른 맥락에서 재사용 하기 어려움.

해결 : 같은 데이터 소스를 다루는 여러 요청을 pub/sub패턴을 이용해 데이터를 가져오는 부분(pub)과  데이터를 소비하는 부분(sub) 로 분리하면 나중에 sub가 늘어나거나 변경사항이 있어도 pub는 변경하지 않고 관심사의 분리가 가능하다.

예시 : 반환된 데이터를 다루는 10개의 구독자가 필요에 따라 존재할 수 있지만 ajax계층은 신경 쓰지 않는다.

ajax계층의 유일한 역할은 데이터 요청과 반환.

반환된 데이터를 어떻게 사용하는지는 구독자가 담당

관심사의 분리로  낮은 결합도를 가진 설계 실현

구독을 통해 뷰만 관심을 가지는 로직

```tsx
    ($ => {
      // Pre-compile template and "cache" it using closure
      const resultTemplate = _.template($('#resultTemplate').html());

      // Subscribe to the new search tags topic
      $.subscribe('/search/tags', (e, tags) => {
        $('#lastQuery').html(`Searched for: ${tags}`);
      });

      // Subscribe to the new results topic
      $.subscribe('/search/resultSet', (e, results) => {
        $('#searchResults')
          .empty()
          .append(resultTemplate(results));
      });

    

    
    })(jQuery);
```

ajax로직만 신경쓸 수 있다.(관심사의 분리)

```tsx
  // Subscribe to new tags being published and perform a search query 
      // using them. Once data has returned, publish this data for the rest
      // of the application to consume.
      $.subscribe('/search/tags', (e, tags) => {
        $.getJSON(
          'http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?',
          {
            tags,
            tagmode: 'any',
            format: 'json',
          },
          ({ items }) => {
            if (!items.length) {
              return;
            }
            $.publish('/search/resultSet', { items });
          }
        );
      });
      
        // Submit a search query and publish tags on the /search/tags topic
      $('#flickrSearch').submit(function(e) {
        e.preventDefault();
        const tags = $(this)
          .find('#query')
          .val();

        if (!tags) {
          return;
        }

        $.publish('/search/tags', [$.trim(tags)]);
      });
```

## 중재자 패턴

- 객체들이 서로를 직접 참조하지 않고, 중재자를 통해서만 통신하게 해서 결합도를 낮추는 것
- 하나의 객체가 이벤트 발생시 다른 객체에게 알림을 보낼 수 있는 디자인패턴

예시)
- 교통관제 시스템의 관제탑(중재자),
- DOM의 이벤트 버블링과 위임에서 최상위 document객체가 중재자 역할
- Express 미들웨어 (추가설명 : 인증, 로깅, 라우터 미들웨어가 있을때 Express가 흐름 조율: Express가 인증 → 로깅 → 라우터 순서를 결정, 새 미들웨어 추가/제거가 다른 코드에 영향 없음)

중재자 패턴 vs 이벤트 집합패턴
- 이벤트가 목적인지 수단인지

중재자, 이벤트 패턴 결합

- 이벤트 집합 패턴을 통해 메뉴와 워크플로(doStuff) 사이의 명확한 분리
- 중재자 패턴을 통해 워크플로의 관리 및 유지보수성을 강화

```javascript
  const menuItem = MyFrameWorkView.extend({
  events:{
    'click .thatThing':'clickedIt'
  },

  clickedIt(e){
    MyFramework.trigger(`menu:click:${this.model.get('name')}`)
  }

  class MyFrameWork{
  constructor(){
    MyFrameWork.on("menu:click:foo", this.doStuff, this)
  }

  static doStuff(){
    //이곳에 여러 객체를 인스턴스화
    //객체의 이벤트 핸들러 설정
    //모든 객체를 의밎있는 워크플로로 조정
  }
}
```