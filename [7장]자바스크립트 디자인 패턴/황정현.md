### 7.1 생성 패턴 (Creational Patterns)

> 객체를 생성하는 과정을 캡슐화하고 추상화하는 디자인 패턴입니다. 객체 생성 로직을 코드에서 분리하여 유연성을 높이고 **결합도**를 낮추는 데 목적이 있습니다.

-----

### 7.2 생성자 패턴 (Constructor Pattern)

생성자는 객체가 새로 만들어진 뒤 초기화하는 데 사용되는 특별한 메서드입니다.

#### 7.2.1 객체 생성 3가지 방법

JavaScript에서 객체를 생성하는 기본적인 방법입니다.

  * **객체 리터럴:** `{}`
  * **Object.create:** `Object.create(prototype)`
  * **new 연산자:** `new Object()`

#### 7.2.2 생성자의 문제점 (ES6 Class 이전)

ES6 `class` 문법이 등장하기 전, 생성자 함수 내부에 메서드를 직접 정의하는 방식은 다음과 같은 문제점이 있었습니다.

```js
function Car(model, year, miles) {
  this.model = model;
  this.year = year;
  this.miles = miles;

  // ❌ 문제: 인스턴스가 생성될 때마다 새로운 함수가 생성됩니다.
  this.toString = function() {
    return `${this.model} has done ${this.miles} miles`;
  };
}
```

  * **메모리 낭비:** `new Car()`를 호출할 때마다 `toString` 함수의 복사본이 각각의 인스턴스에 생성됩니다. 100개의 인스턴스는 100개의 독립적인 함수를 갖게 됩니다.
  * **성능 저하:** 인스턴스마다 함수 객체를 생성하는 비용이 발생합니다.
  * **상속의 어려움:** 프로토타입 체인을 통한 상속 및 메서드 오버라이딩이 복잡해집니다.

#### 7.2.3 프로토타입을 활용한 개선

이 문제를 해결하기 위해 메서드를 \*\*프로토타입(prototype)\*\*에 정의합니다. 프로토타입 객체는 특정 생성자의 모든 인스턴스가 공유하는 공통 메서드와 속성을 저장하는 공간입니다.

**방법 1: ES5 프로토타입 (명시적)**

```js
// 생성자는 데이터(속성)만 담당
function Car(model, year, miles) {
  this.model = model;
  this.year = year;
  this.miles = miles;
}

// 메서드는 프로토타입에 정의 (모든 인스턴스가 공유)
Car.prototype.toString = function() {
  return `${this.model} has done ${this.miles} miles`;
};
```

**방법 2: ES6 Class (암묵적, 권장)**

ES6 `class` 문법은 이 과정을 훨씬 **가독성** 있게 만들어줍니다. `class` 내부에 정의된 메서드는 자동으로 `prototype`에 저장됩니다.

```js
class Car {
  constructor(model, year, miles) {
    this.model = model;
    this.year = year;
    this.miles = miles;
  }

  // ✅ 이 메서드는 Car.prototype에 저장됩니다.
  // (위의 '방법 1'과 기능적으로 동일합니다)
  toString() {
    return `${this.model} has done ${this.miles} miles`;
  }
}
```

-----

### 7.3 모듈 패턴 (Module Pattern)

> 프로젝트를 구성하는 코드를 **높은 응집도**와 **낮은 결합도**를 갖도록 체계적으로 분리 및 관리하는 패턴입니다. React, TypeScript 개발에서 가장 기본이 되는 패턴입니다.

#### 7.3.1 객체 리터럴

가장 간단한 모듈의 형태로, 관련된 데이터와 함수를 하나의 객체로 묶는 방식입니다.

```js
const person = {
  name: 'Jun',
  // 메서드 단축 표현
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  },
};
```

#### 7.3.2 비공개 멤버를 가진 모듈 (ESM)

ES Modules (ESM)는 `export` 키워드를 사용하지 않은 변수나 함수를 모듈 스코프 내의 **비공개(private)** 멤버로 자연스럽게 만듭니다.

```js
// counter.js

// 이 변수는 모듈 외부에서 접근할 수 없는 비공개 멤버입니다.
let counter = 0;

// 외부에 공개할 함수만 export 합니다.
export function incrementCounter() {
  counter++;
}

export function resetCounter() {
  counter = 0;
}

export function getCounter() {
  return counter;
}

// 편의를 위해 객체로 묶어 default export 할 수도 있습니다.
export default { incrementCounter, resetCounter, getCounter };
```

  * **이점:**
      * **정보 은닉(Encapsulation):** 외부에서 `counter` 변수에 직접 접근(수정)하는 것을 막아 **예측 가능성**을 높입니다.
      * **디버깅 용이:** 모듈 스코프가 명확히 분리되어 디버거에서 콜 스택을 추적하기 쉽습니다.

#### 7.3.3 모듈 믹스인 (Module Mixin)

고차 함수(Higher-Order Function)를 기반으로 모듈에 기능을 "믹스인(mixin)"하여 기능을 수평적으로 확장(X축 확장)합니다. 이는 React의 \*\*HOC(고차 컴포넌트)\*\*나 \*\*커스텀 훅(Custom Hook)\*\*과 매우 유사한 접근 방식입니다.

```js
// 기능 1: 로깅 기능 추가
const withLogger = (module) => ({
  ...module,
  log(msg) {
    console.log(`[LOG]: ${msg}`);
  },
});

// 기능 2: 타이머 기능 추가
const withTimer = (module) => ({
  ...module,
  _start: 0, // 비공개 멤버처럼 사용
  start() {
    this._start = Date.now();
  },
  stop() {
    console.log('Elapsed:', Date.now() - this._start);
  },
});

// 기본 모듈
const baseModule = { name: 'Jun' };

// 믹스인 조합 (함수형 프로그래밍의 '조합(Composition)')
const Enhanced = withTimer(withLogger(baseModule));

// 사용
Enhanced.log('hello'); // [LOG]: hello
Enhanced.start();
setTimeout(() => Enhanced.stop(), 1000); // Elapsed: 1001 (약 1초)
```

  * **클래스 상속 (Y축 확장)과 비교:**
      * **상속:** 부모-자식 관계가 깊어질수록 **결합도**가 급격히 높아지고, 동작을 이해하기 위해 전체 상속 트리를 따라가야 합니다. (e.g., `class EnhancedModule extends TimerModule { ... }`)
      * **믹스인:** 필요한 기능을 독립적으로 개발하여 조합하므로 **결합도가 낮고** 재사용성이 높습니다. 다중 상속 문제도 없습니다.

#### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴

`WeakMap`은 키(key)로 사용된 객체에 대한 참조를 "약하게(weakly)" 유지합니다.

  * **Map (강한 참조):** `map.set(obj, "data")` 후 `obj = null`로 만들어도, `map`이 `obj`를 참조하고 있어 가비지 컬렉터(GC)가 `obj`를 메모리에서 제거하지 못합니다. (메모리 누수 위험)
  * **WeakMap (약한 참조):** `weakMap.set(obj, "data")` 후 `obj = null`이 되면, 다른 곳에서 `obj`를 참조하지 않을 경우 GC가 `obj`를 메모리에서 제거합니다. 이때 `weakMap`에서도 해당 항목이 자동으로 정리됩니다.

**활용:**
`WeakMap`은 "언제든 사라져도 괜찮은" 부가 데이터를 저장할 때 유용합니다. (캐시, DOM 관련 메타데이터 등)
`zustand`, `jotai` 같은 React 상태 관리 라이브러리들이 객체(상태)와 관련된 내부 데이터를 `WeakMap`에 저장하여, 상태 객체가 더 이상 사용되지 않을 때 관련 데이터도 함께 메모리에서 정리되도록 합니다.

-----

### 7.4 노출 모듈 패턴 (Revealing Module Pattern)

> 모듈 패턴의 변형으로, 모든 변수와 함수를 비공개로 정의한 뒤, 외부에 노출(reveal)할 것만 골라 객체 리터럴로 반환하는 패턴입니다. 코드의 **가독성**과 일관성을 높여줍니다.

```js
// ES 모듈 환경에서 구현한 노출 모듈 패턴
let privateVar = 'Rob Dodson';
const publicVar = 'Hey there!';

const privateFunction = () => {
  console.log(`Name:${privateVar}`);
};

const publicSetName = (strName) => {
  privateVar = strName;
};

const publicGetName = () => {
  privateFunction();
};

// 외부에 공개할(노출할) 포인터만 정의
const myRevealingModule = {
  setName: publicSetName,
  greeting: publicVar,
  getName: publicGetName,
};

export default myRevealingModule;
```

  * **장점:** 모듈의 공개 API(인터페이스)가 객체 하단에 명확하게 드러나 **가독성**이 좋습니다.
  * **단점:** 비공개 멤버를 참조하는 공개 멤버를 외부에서 동적으로 수정(패치)하기 어렵습니다. (이는 단점이라기보다 **예측 가능성**을 높이는 특징일 수 있습니다.)

-----

### 7.5 싱글톤 패턴 (Singleton Pattern)

> 클래스의 인스턴스가 오직 **하나만** 존재하도록 제한하고, 이 인스턴스에 대한 전역적인 접근 지점을 제공하는 패턴입니다.

  * **특징:**
      * 애플리케이션 전반에 걸쳐 단 하나만 존재해야 하는 객체(예: 설정 관리자, 로거, DB 연결 풀)에 사용됩니다.
      * `getInstance()` 메서드를 통해 항상 동일한 인스턴스를 반환받습니다.

<!-- end list -->

```js
// IIFE(즉시 실행 함수)와 클로저를 활용한 싱글톤 구현
const Singleton = (function() {
  let instance; // 비공개 변수로 인스턴스를 저장

  // 인스턴스 생성 로직 (비공개)
  function createInstance() {
    // 비공개 데이터
    let privateData = 'I am private';
    let privateCounter = 0;
    
    // 외부에 공개될 인터페이스
    return {
      publicMethod() {
        console.log('Public method called');
      },
      getPrivateData() {
        return privateData;
      },
      incrementCounter() {
        privateCounter++;
        return privateCounter;
      }
    };
  }
  
  // 전역에서 접근할 공개 인터페이스
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// --- 사용 ---
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2);  // true ✅ (항상 같은 인스턴스)

console.log(instance1.incrementCounter());  // 1
console.log(instance2.incrementCounter());  // 2 (같은 카운터를 공유)
```

  * **단점 (주의):**
      * **높은 결합도:** 많은 모듈이 싱글톤 인스턴스를 직접 참조하면 **결합도**가 높아집니다.
      * **예측 불가능성:** 전역 상태를 만들기 때문에 코드의 **예측 가능성**을 떨어뜨리고 테스트하기 어렵게 만듭니다. (React에서는 `Context API`나 `zustand` 같은 전역 상태 관리로 대체하는 것이 좋습니다.)

-----

### 7.6 프로토타입 패턴 (Prototype Pattern)

> 이미 존재하는 객체(프로토타입)를 복제하여 새 객체를 생성하는 패턴입니다. `Object.create()`가 이 패턴의 핵심입니다.

객체 생성 비용이 비쌀 때, 프로토타입을 기반으로 효율적인 복제가 가능합니다.

```js
// 원본 객체 (프로토타입)
const carPrototype = {
  drive() {
    console.log("Weeee. I'm driving!");
  },
  panic() {
    console.log('Wait. How do you stop this thing?');
  },
};

// 프로토타입을 기반으로 새 객체를 생성하는 함수
const createCar = (name) => {
  // carPrototype을 부모(__proto__)로 하는 새 객체를 생성
  const car = Object.create(carPrototype);
  car.name = name; // 새 객체 고유의 속성
  return car;
};

const myCar = createCar('Ford Escort');
myCar.drive(); // Weeee. I'm driving!
```

-----

### 7.7 팩토리 패턴 (Factory Pattern)

> 객체를 생성하는 구체적인 로직(어떤 `new`를 호출할지)을 팩토리(공장) 클래스/함수로 분리하는 패턴입니다.

객체 생성이 복잡하거나, 조건에 따라 다른 타입의 객체를 생성해야 할 때 유용합니다. 이는 **결합도**를 낮추고 코드의 **가독성**을 높입니다.

```js
// --- 생성될 클래스들 ---
class Car {
  constructor({ doors = 4, state = 'brand new', color = 'silver' } = {}) {
    this.doors = doors;
    this.state = state;
    this.color = color;
  }
}

class Truck {
  constructor({ state = 'used', wheelSize = 'large', color = 'blue' } = {}) {
    this.state = state;
    this.wheelSize = wheelSize;
    this.color = color;
  }
}

// --- 팩토리 클래스 ---
class VehicleFactory {
  // 기본값으로 Car를 생성하도록 설정
  constructor() {
    this.vehicleClass = Car;
  }

  // 객체 생성을 담당하는 메서드
  createVehicle(options) {
    const { vehicleType, ...rest } = options;

    // 조건에 따라 생성할 클래스를 동적으로 결정
    switch (vehicleType) {
      case 'car':
        this.vehicleClass = Car;
        break;
      case 'truck':
        this.vehicleClass = Truck;
        break;
    }

    // 실제 인스턴스 생성은 여기서만 발생
    return new this.vehicleClass(rest);
  }
}

// --- 사용 ---
const vehicleFactory = new VehicleFactory();

// 팩토리를 사용하는 코드는 'Car'나 'Truck'의 존재를 몰라도 됩니다.
// 오직 'vehicleType' 옵션만 전달하면 팩토리가 알아서 처리합니다.

const car = vehicleFactory.createVehicle({
  vehicleType: 'car',
  color: 'yellow',
  doors: 6,
});

const truck = vehicleFactory.createVehicle({
  vehicleType: 'truck',
  color: 'red',
  wheelSize: 'medium',
});
```
