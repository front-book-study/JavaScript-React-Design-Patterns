# 7.9 퍼사드 패턴

#### 정의

**복잡성을 숨기고**, 사용하기 편리한 **높은 수준의 인터페이스를 제공**하는 패턴


#### 특징

- jQuery에서 흔히 볼 수 있는 패턴
- 숨겨진 하위 시스템이 아닌 바깥에 나타난 퍼사드와 직접 상호작용
- 하위 시스템과 간접적으로 상호작용하여 에러 줄임
- 클래스의 인터페이스를 단순화하고, 코드의 구현 부분과 사용 부분을 분리

#### 장점

- 사용하기 쉬움
- 패턴 구현에 필요한 코드의 양이 적음

# 7.10 믹스인패턴

서브클래스가쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스

최소한의 복잡성으로 객체의 기느을 빌리거나 상속할 수 있게해줌

```jsx
   // Car class
      class Car {
        constructor({ model = 'no model provided', color = 'no color provided' }) {
          this.model = model;
          this.color = color;
        }
      }

      // Mixin function
      function Mixin(BaseClass) {
        return class extends BaseClass {
          driveForward() {
            console.log('drive forward');
          }
          driveBackward() {
            console.log('drive backward');
          }
          driveSideways() {
            console.log('drive sideways');
          }
        };
      }

      // MyCar class extending Car with Mixin
      class MyCar extends Mixin(Car) {}

      // Create Car function
      function createCar() {
        const car = new MyCar({});
        displayCar(car);
      }

      // Create Sports Car function
      function createSportsCar() {
        const sportsCar = new MyCar({
          model: 'Porsche',
          color: 'red',
        });
        displaySportsCar(sportsCar);
      }

      // Display Car details
      function displayCar(car) {
        const output = document.getElementById('carOutput');
        output.innerHTML = `
          <p><strong>Model:</strong> ${car.model}</p>
          <p><strong>Color:</strong> ${car.color}</p>
        `;
        car.driveForward();
        car.driveBackward();
      }

      // Display Sports Car details
      function displaySportsCar(sportsCar) {
        const output = document.getElementById('sportsCarOutput');
        output.innerHTML = `
          <p><strong>Model:</strong> ${sportsCar.model}</p>
          <p><strong>Color:</strong> ${sportsCar.color}</p>
        `;
        sportsCar.driveSideways();
      }
```

https://legacy.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html

### 장점

- 중복을 줄이고 재사용성을 높임

### 단점

- 객체의 프로토타입에 기능을 직접 주입하는 것은 나쁜 방법
- 프로토타입 오염
- 함수의 출처에 대한 불확실성

> 리엑트 팀
컴포넌트의 유지보수와 재사용을 복잡하게 만든다는 이유로 믹스인 반대
대신 고차 컴포넌트나 훅을 장려
> 

> 저자
문서화를 잘해두고면 혼란을 최소화 가능
구현 과정에서 주의를 기울인다면 괜찮다


# 데코레이터 패턴

목표: 코드 재사용성 

믹스인과 마찬가지로 객체 서브클래싱의 달느 방법

기존 클래스에 동적으로 기능 추가 위해 사용
애플리케이션의 기능이 다양한 타입의 객체를 필요로 하룻 있어 사용

#### 장점

- 시스템의 내부 코드를 힘겹게 바꾸지 않고도 기능추가 가능


```jsx
      // Abstract MacBook class
      class MacBook {
        cost() {
          // Abstract method, to be implemented by concrete subclasses
        }

        description() {
          // Abstract method, to be implemented by concrete subclasses
        }
      }

      // Concrete MacBook class
      class ConcreteMacBook extends MacBook {
        cost() {
          return 997;
        }

        description() {
          return 'MacBook';
        }
      }

      // Abstract Decorator class
      class AbstractDecorator extends MacBook {
        constructor(macBook) {
          super();
          this.macBook = macBook;
        }

        cost() {
          return this.macBook.cost();
        }

        description() {
          return this.macBook.description();
        }
      }

      // Concrete Decorator classes
      class RAMDecorator extends AbstractDecorator {
        constructor(macBook, ram) {
          super(macBook);
          this.ram = ram;
        }

        cost() {
          return super.cost() + (this.ram === 8 ? 200 : 100);
        }

        description() {
          return super.description() + `, ${this.ram}GB RAM`;
        }
      }

      class EngravingDecorator extends AbstractDecorator {
        cost() {
          return super.cost() + 50;
        }

        description() {
          return super.description() + ', Engraving';
        }
      }

      class ParallelsDecorator extends AbstractDecorator {
        cost() {
          return super.cost() + 150;
        }

        description() {
          return super.description() + ', Parallels';
        }
      }

      class CaseDecorator extends AbstractDecorator {
        cost() {
          return super.cost() + 100;
        }

        description() {
          return super.description() + ', Case';
        }
      }

      class InsuranceDecorator extends AbstractDecorator {
        cost() {
          return super.cost() + 200;
        }

        description() {
          return super.description() + ', Insurance';
        }
      }

```

### 덕타이핑을 사용해 자바스크립트의 인터페이스를 구현하는 예제

## 추상 데코레이터

기존 데코레이터는 초가 옵션에 대해 조합을 개별 서브클래스로 만들어야하는 불편함이 있음

모든 조합의서브클래스를 만드는 대신 5개의 데코레이터 클래스를 만든다.

### 장점

- 컴포넌트 구조 유지하면서  기능 확장
- 같은 인터페이스를 사용하여 호환성 높음

```jsx
 // Define MacBook interface
      const MacBook = new Interface('MacBook', [
        'addEngraving',
        'addParallels',
        'add4GBRam',
        'add8GBRam',
        'addCase',
        'getPrice',
      ]);

      // MacBook Pro class
      class MacBookPro {
        addEngraving() {
          return 'Added Engraving';
        }

        addParallels() {
          return 'Added Parallels';
        }

        add4GBRam() {
          return 'Added 4GB RAM';
        }

        add8GBRam() {
          return 'Added 8GB RAM';
        }

        addCase() {
          return 'Added Case';
        }

        getPrice() {
          return 900.0;
        }
      }
```
