### 팩토리 패턴

- 캡슐화하는 대상 : 어떤 클래스가 생성될지, new가 언제 호출될지
- 외부에서 알아야 하는 것 : 생성하려는 객체 종류 또는 조건
- ex ) React.createElement
- 장점 :
    - 객체 생성 로직을 **한 곳(팩토리)** 에 모아 관리할 수 있음.
    - 외부 코드가 **구체적인 클래스(Dog, Cat)** 에 의존하지 않아 **결합도를 낮춰줌.**
    - 새로운 타입(Bird)이 추가되더라도 **외부 코드 수정 없이 확장(OCP)** 가능.
    - 객체 생성 로직이 숨겨져 있어 **캡슐화**가 강화.


------------------------------------------------------------------------------
#  구조패턴 (Structural Pattern)

### 퍼사드 패턴 (Facade Pattern)
- 문제 : 하위 시스템(모듈)들이 너무 많아서, 클라이언트가 직접 다루기엔 API가 복잡하고 결합도가 높다.
- 해결 : 여러 복잡한 기능을 하나로 묶는 단순한 “앞문(Facade)” 클래스를 두고, 클라이언트는 Facade만 사용하도록 한다.

### 믹스인 (Mixin Pattern)
- 여러 클래스를 상속하고 싶을 때 사용? 

### 데코레이터 패턴 (Decorator Pattern)

특징
- 상속을 하지 않고 객체를 여러 데코레이터로 랩핑함.
- 런타임에 동적으로 기능 추가 및 변경이 가능함.
- 서브클래스를 활용할 때보다 더 유연하게 기능확장 가능.

사용시점
- 클래스의 기본 기능에 필수적이지 않으나 다양한 배리에이션을 주고 싶을 때
- 기존 객체를 수정하지 않고 동적으로 추가 기능을 할당하고 싶을 때
- 상속을 통한 서브 클래싱이 자유롭지 않은 경우

예제
- 예제 코드에서 getCost가 오버라이딩 되면서 997 + 75 + 2000 + 250 = 1522
- 반면, screensize는 유지되어 기존값인 11.6 유지
- Macbook의 서브 클래스가 아닌 Macbook + 옵션을 데코레이터를 활용하여 구현

### 플라이웨이트 패턴
- 문제 : 엄청 많은 객체(수천~수만)를 만들 때, 공유 가능한 속성(변하지 않는 부분) 때문에 메모리가 과하게 사용된다.
- 해결 : 상태를 **내부 상태(공유 가능: intrinsic)**와 **외부 상태(각 인스턴스별: extrinsic)**로 나누고, 내부 상태는 공유 객체로 재사용한다.