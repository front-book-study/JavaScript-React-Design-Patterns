### 7.1 생성 패턴
- 생성자 패턴
- 모듈 패턴
- 노출 모듈 패턴
- 싱글톤 패턴
- 프로토타입 패턴
- 팩토리 패턴

### 7.2 생성자 패턴
`생성자(constructor)`는 객체가 새로 만들어진 뒤 초기화하는데 사용되는 특별한 메서드이다. 
ES2015 버전 이후로 생성자를 가진 클래스를 만들 수 있게 되었고, 이를 통해 클래스의 인스턴스 객체를 생성할 수 있다.
자바스크립트에서는 거의 모든 것이 객체인데, 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 `문법적 설탕`이기도 하다. 

#### 7.2.1 객체 생성
자바스크립트에서 새로운 객체를 만들 때 사용하는 일반적인 3가지 방법
```
// 1. 리터럴 표기법을 사용하여 빈 객체 생성
const newObject()
// 2. Object.create() 메서드를 사용하여 빈 객체 생성
const newObject = Object.create(Object.prototype)
// 3. new 키워드를 사용하여 빈 객체 생성
const newObject = new Object()
```

위와 같은 방법으로 만들어진 객체에 키와 값을 할당할 수 있다
```
// ECMAScript 3 호환 방식
// 1. 도트Dot(.) 문법
newObject.someKey = 'Hello World';

//2. 대괄호 문법
newObject["someKey"] = 'Hello World';

// ECMAScript 5만 호환되는 방식
//3. Object.defineProperty
Object.definePropoerty(newObject, "someKey", {
    value: '...'
    writable: true,
    enumeralbe: true,
    configurable: true
});
// 이렇게 함수로 래핑하여 간단하게도 가능
var defineProp = function (obj, key, value) {
    config.value = value
    Object.defineProperty(obj, key, config)
};

//5. Object.definedProperties
Object.defineProperties(newObject, {
    "someKey": {
        value: 'Hello world',
        writable: true
    }
})
```
이렇게 객체를 상속할 수도 있다.
```
// person이라는 객체를 상속하는 driver 객체
const driver = Object.create(person)
// 속성 할당
definedProp(driver, 'topSpeed', '100mph')
```

#### 7.2.2 생성자의 기본 특징
클래스는 새 객체를 초기화하는 `constructor()`라는 이름의 메서드를 가지고 있어야 한다. 또한 `new` 키워드는 생성자를 호출할 수 있으며 생성자 내부에서 사용된 `this` 키워드는 새로 생성된 해당 객체를 가리킨다. 
```
class Car {
    constructor(model, year, miles){
        this.model = model;
        this.year = year;
        this.miles = miles;
    }
    toString() {
        return `${this.model}....`;
    }
}

// 새로운 Car인스턴스 생성
let civic = new Car('Honda Civic', 2009, 20000);
```
위는 생성자 패턴의 간단한 예제이나 몇가지 문제가 있다.
1. 상속이 어려워짐
2. Car 생성자로 객체를 생성할 때마다 toString()과 같은 함수를 새로 정의한다.

Car 유형의 인스턴스는 모두 동일한 함수를 공유해야 하므로 이 방법은 효과적이지 않다.

> ????저렇게 쓰는게 같은 함수를 공유하는게 아닌가..?

#### 7.2.3 프로토타입을 가진 생성자
자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통메서드를 쉽게 정의할 수 있게 한다. 생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다. 이러한 방식으로 동일한 프로토타입 객체를 사용하는 여러 개의 Car객체를 만들 수 있다.
```
class Car {
    constructor(model, year, miles){
        this.model = model;
        this.year = year;
        this.miles = miles;
    }
    // 프로토타입 객체의 재정의를 피하기 위해 Object.prototype 대신
    // Object.protoType.newMethod 형태를 사용하고 있음
    // 기존에 이미 정의된 프로토타입 객체를 유지하기 위해서임
    Car.proptotype.toString = function() {
        return `${this.model}....`;
    }
}
```
> ??

### 7.3 모듈 패턴
모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는데 효과적으로 활용된다. 
초기 자바스크립트는 
- 객체 리터럴 표기법
- 모듈 패턴
- AMD 모듈
- CommonJS 모듈
와 같은 방법들로 모듈을 구현했다. 

#### 7.3.1 객체 리터럴
객체 리터럴 표기법은 객체는 중괄호({}) dksdptj 키와 값을 쉼표로 구분하여 객체를 정의하는 방법이다.
```
const myObejctLiteral = {
    variableKey: variableVAlue,
    funtionKey() {
        ///
    }
}
```
객체 리터럴은 선언 시 new 연산자를 필요로 하지않으며, `{`를 통해 객체 블록의 시작을 명시한다. 
객체 리터럴 표기법을 사용해 모듈을 정의할 수 있다.
```
const myModule = {
    myProperty: 'someValue',
    // 객체 리터럴은 속성으로 값과 메서드를 모두 가질 수 있다.
    // 예를 들어 객체 안에 객체를 다시 생성할 수도 있다.
}
```

#### 7.3.2 모듈 패턴
모듈패턴은 전통적인 소프트웨어 엔지니어링 분야에서 **클래스의 캡슐화**를 위해 처음 고안되었다.
재사용 가능한 로직을 분할하고 관리하기 위해 개별 스크립트에 의존했으며, 그 결과 하나의 HTML파일에서 10~20개의 스크립트를 각각 수동으로 가져와야 했다. 객체를 활용하는 모듈 패턴은 그저 `공개`및 `비공개` 메서드를 가진 로직을 캡슐화하는 방법 중 하나였다. 시간이 지나며 여러 커스텀 모듈 시스템이 등장했는데, 자바스크립트 모듈을 사용해 객체, 함수, 클래스,변수 등을 다른 파일에 쉽게 내보내거나 가져올 수 있게되었다.

#### 비공개
모듈 패턴은 클로저를 활용해 비공개 상태와 구성을 캡슐화한다. 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다. 모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수있다. 

ES2019(ES10) 이전의 자바스크립트에서는 접근 제한자(#)를 지원하지 않아 비공개라는 개념이 존재하지 않았다. 당시엔 변수를 공개 또는 비공개로 선언하는 방법이 없어 함수 스코프를 이용해 비공개 개념을 구현했다. 모듈 파턴에서는 클로저를 통해  비공개를 구현하여, 선언된 모듈 내부에서만 변수와 메서드를 사용할 수 있다. 하지만 반환되는 객체에 포함된 변수와 메서드는 공개되어 다른 곳에서도 사용할 수있다.

```
let counter = 0;
const testModule = {
    fn1(){
        return counter++
    }
    fn2() {
        return counter--
    }
}
export default testModule;

import testModule from './testModule'l
testModule.fn1();
testModule.fn2();
```
다른 파일들은 fn1()를 직접 읽지 못하며 counter 변수는 전역 스코프로부터 완전히 보호되어 비공개 변수로서 작동한다. 모듈의 클로저 내부로 스코프가 제한되어 오직 fn() 메서드만이 접근할 수 있다. 
- 비공개 자유성: 모듈 내부에서만 사용 가능한 비공개 함수를 자유롭게 만들 수 있다. 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.
- 디버깅 용이성: 대개 함수는 선언되고 이름이 정해지므로, 어떤 함수가 예외를 발생시켰는지 알아내려고 할때 디버거에서 콜스택을 찾기 쉬워짐.

#### 7.3.3 모듈 패턴의 변형
#### 믹스인 가져오기 변형
유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차함수에 인자로 전달할 수 있게 한다. 이를 통해 전역 스코프 요소를 가져와 맘대로 이름을 지정할 수 있다.
```
//util.js
export const min = (arr) => Math.min(...arr);

//priovateMethods.js
import {min} from './util.js';

export const privateMehod = () => {
    console.log(min([10,3,4])
}

// myModule.js
import {privateMehod} from './privateMethods';

const myModuel = () => ({
    publicMethod(){
        privateMethod();
    }
})
export default MyModule;

//main.js
import myModule from './myModule';

const moduleInstance = myModule();
moduleInstance.publicMethod();
```

#### 내보내기 변형
다음 변형은 따로 이름을 지정해주지 않고 전역 스코프로 변수를 내보낸다. 
> 예제의 privateMethod는 어디에 쓰이는 것임..?

#### 장점
자바스크립트 관점에서 볼 때 모듈 패턴은 캡슐화 개념보다 객체 지향 프로그래밍 지식을 가진 초보 개발자가 이해하 쉽다. 믹스인 가져오기를 보면 모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하고 독립적으로 만들어 준다. 
그리고 export 를 이용해 비공개를 지원한다. 
모듈 패턴은 공개되면 안되는 코드를 캡슐화 할 수 있고 여러 의존성을 동시에 사용할 수 있으며 이름의 충돌도 피할 수 있다. 다만 구버전에서 ES2015모듈을 사용하려면 바벨과 같은 트랜스파일러가 필요하다.

#### 단점
모듈 패턴의 단점은 공개와 비공개 멤버를 서로 다르게 접근해야 한다는 것이다. 공개 여부를 바꾸고 싶다면 값이 위치한 파일로 가서 각각 바꾸어주어야한다. 
또한 나중에 추가한 메서드에서는 비공개 멤버에 접근할 수 없다.
자동화 단위 테스트에서 비공개 멤버는 제외된다는 점
핫픽스가 필요한 오류를 고칠 때 복잡도를 높인다.

#### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴
ES6에서 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체이다. 키는 객체여야만 하나, 값으로는 뭐든지 넣을 수 있다. WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵이다. (=== 참조되지 않는 키는 가비지 컬렉션(GC)의 대상이 됨)
```
let _counter = new WeakMap();

class Module {
    constructor(){
        _counter.set(this, 0);
    }
    incrementCount(){
        let counter = _counter.get(this);
        counter++;
        _counter.set(this, counter);
        
        return _counter.get(this);
    }
}
```
> 현재는 비공개 필드를 지원하기때문에 weakMap을 사용하는 일은 거의 없다.

### 7.4 노출 모듈 패턴
크리스티안 하일만의 노출패턴은 공개 변수나 메서드에 접근하기 위해 가져온 메인객체의 이름을 반복해서 사용해야 한다는 점에 대해 답답함을 느끼며 생겼다. 또한 그는 객체 리터럴 표기법을 사용해 요소를 공개하는 것도 맘에 들어하지않았다.
그 결과 모든 함수와 변수를 비공개 스코프에 정의하고 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴이 탄생했다. 
ES2015+에서는 모듈 스코프 안에 정의된 함수와 변수는 비공개 처리된다. 그리고 export와 import를 통해 공개 여부를 결정한다.

#### 장점
노출 모듈 패턴을 사용하면 코드의 일관성이 유지된다. 또한 모듈의 가장 아래에위치한 공개 객체를 더 알아보기 쉽게 바꾸어 가독성을 향상시킨다. 
#### 단점
비공개 함수를 참조하는 공개함수를 수정할 수없다. 비공개 함수가 비공개 구현을 참조하기 때문에 수정을 해도 함수가 변경될 뿐 참조된 구현이 변경되는 것은 아니다. 비공개 변수를 참조하는 공개 객체 멤버 또한 수정이 불가능하다. 
따라서 노출 모듈 패턴으로 마들어진 모듈은 기존 모듈 패턴보다도 취약할 수 잇으므로 사용에 주의해야한다.
> 커스텀훅으로 많이 사용되는 방법


### 7.5 싱글톤 패턴
싱글톤패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다. 이 패턴은 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.
싱글톤 패턴을 구현하려면 이미 존재하는 인스턴스가 없어야 한다. 인스턴스가 이미 존재할 경우에는 해당 인스턴스의 참조를 반환한다. 

싱글톤 패턴은 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있는데 초기화 시점에 필요한 특정 정보가 유효하지 않을 수도 있끼 때문이다. 싱글톤 클래스의 인스턴스가 이미 생서되어ㅏㅆ다는 사실을 모른다면 해당 인스턴스를 찾아 사용하기 어렵다.
이는 **싱글톤이 객체나 클래스가 아닌 구조**이기 때문이다.

ES2015+에서는 자바스크립트 클래스의 전역 인스턴스를 단 한 번만 생성하는 싱글톤 패턴을 구현할 수 있으며, 모듈 내보내기를 통해 싱글톤 인스턴스를 바깥에서 사용할 수 있게 노출할 수도 있다. 이를 통해 싱글톤 인스턴스에 대한 접근을 좀 더 명시적이고 통제할 수있게 되며 다른 전역 변수와도 구분할 수 있다.
-> 새로운 클래스 인스턴스를 생성할 수는 없으나 클래스 내에 공개된 get, set 메서드를 통해 인스턴스를 읽거나 수정할 수 있다. 


싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용한다는 점이다.
- 클래스의 인스턴스는 정확히 하나만 있어야 하며 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야 한다.
- 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있어야하고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야한다. 

#### 7.5.1 리액트의 상태 관리
싱글톤 대신 Context API나 리덕스같은 전역 상태 관리 도구를 이용하여 개발할 수 있다. 싱글톤과는 달리, 이러한 전역 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다.


### 7.6 프로토 타입 패턴
이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
프로토타입 패턴은 프로토타입 상속을 기반으로 한다. 이패턴에서는 프로토타입 역할을 할 전용 객체를 생성하는데 이렇게 만들어진 `prototype` 객체는 생성자를 통해 만들어진 객체의 설계도가 된다. 예를들어 생성자 함수의 프로토타입이 name 속성을 가지고 있따면 해 생성자 함수를 사용해 만들어진 객체는 모두 name 속성을 가지게 된다.  

생성자 패턴 - 객체를 어떻게 만드는가 에 대한 패턴 
프로토타입 - 만들어진 객체들이 무엇을 공유하는가에 대한 매커니즘

ES2015에서는 객체를 생성하기 위해 클래스와 생성자를 사용할 수 있다. 하지만 내부적으로는 클래스와 생성자도 결국 함수와 프로토타입으로 컴파일되어버린다. 즉 클래스와 생성자를 사용한다고 하더라도 여전히 프로토타입의 장점과 동시에 성능상 이점을 누리고 있는 것이다.


### 7.7 팩토리 패턴
팩토리 패턴은 객체를 생성하는 생성 패턴의 하나이다. 다른 패턴과 달리 생성자를 필요로 하지 않지만 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다.

팩토리 패턴은 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 객체 생성과정이 복잡할 때 특히 유용하다
```
class Dog {
  speak() {
    console.log("Woof!");
  }
}
class Cat {
  speak() {
    console.log("Meow!");
  }
}

class AnimalFactory {
  static createAnimal(type) {
    switch (type) {
      case "dog":
        return new Dog();
      case "cat":
        return new Cat();
      default:
        throw new Error("Unknown animal type");
    }
  }
}

const dog = AnimalFactory.createAnimal("dog");
dog.speak(); // Woof!

const cat = AnimalFactory.createAnimal("cat");
cat.speak(); // Meow!
```
외부 코드는 단순히 Factory.createAnimal("dog")만 호출
-> 객체 생성방식을 몰라도 됨(캡슐화)

#### 7.7.1 팩토리 패턴을 사용하면 좋은 상황
- 객체나 컴포넌트 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕타이핑과 같은 API규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할때, 또한 디커플링에도 유용하다

#### 7.7.2 팩토리 패턴을 사용하면 안 되는 상황
객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 차라리 위험을 피해 생성자를 사용하는 것이 좋다. 
팩토리 패턴은 객체 생성 과정을 인터페이스 뒤에 추성화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가할 수 있다.


#### 7.7.3 추상 팩토리 패턴
추상 팩토리 패턴은 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴이다. 객체가 어떻게 생성되는지에 대한 세부사항을 알 필요 없이 객체를 사용할 수 있게 한다. 
객체의 생성 과정에서 영향을 받지 않아야 하거나 여러 타입의 객체로 작업해야하는 경우에 추상 팩토리를 사용하면 좋다.


### 7.8 구조패턴
구조패턴은 클래스와 객체의 구성을 다룬다. 구조 패턴은 클래스와 객체를 체계적으로 구성하는 최고의 방법과 사례를 제공한다
- 퍼사드 패턴
- 믹스인 패턴
- 데코레이터 패턴
- 플라이웨이트 패턴

### 7.9 퍼사드 패턴
퍼사드패턴은 심층적인 복잡성(모듈, API, 클래스 등)을 숨기고 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴이다. 

내부에는 복잡한 로직이 여러 단계로 얽혀 있지만 외부에서는 단 하나의 단순한 메서드만 호출하면 되는 구조

```
function useApi() {
  const get = async (url) => { /* axios.get + error처리 + loading */ };
  const post = async (url, body) => { /* axios.post + 공통헤더 */ };
  return { get, post };
}
```
복잡한 HTTP로직을 훅으로 감싸고 외부에선 단순히 useApi().get("/user")만 호출하면 된다.

### 7.10 믹스인 패턴
C++나 Lisp 같은 전통적인 프로그래밍 언어에서 믹스인은 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스이다.

### 7.11 서브 클래싱
서브클래싱이랑 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것을 뜻한다. 

### 7.12 믹스인 패턴
