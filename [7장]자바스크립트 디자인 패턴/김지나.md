### 7.1 생성 패턴
- 생성자 패턴
- 모듈 패턴
- 노출 모듈 패턴
- 싱글톤 패턴
- 프로토타입 패턴
- 팩토리 패턴

### 7.2 생성자 패턴
`생성자(constructor)`는 객체가 새로 만들어진 뒤 초기화하는데 사용되는 특별한 메서드이다. 
ES2015 버전 이후로 생성자를 가진 클래스를 만들 수 있게 되었고, 이를 통해 클래스의 인스턴스 객체를 생성할 수 있다.
자바스크립트에서는 거의 모든 것이 객체인데, 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 `문법적 설탕`이기도 하다. 

#### 7.2.1 객체 생성
자바스크립트에서 새로운 객체를 만들 때 사용하는 일반적인 3가지 방법
```
// 1. 리터럴 표기법을 사용하여 빈 객체 생성
const newObject()
// 2. Object.create() 메서드를 사용하여 빈 객체 생성
const newObject = Object.create(Object.prototype)
// 3. new 키워드를 사용하여 빈 객체 생성
const newObject = new Object()
```

위와 같은 방법으로 만들어진 객체에 키와 값을 할당할 수 있다
```
// ECMAScript 3 호환 방식
// 1. 도트Dot(.) 문법
newObject.someKey = 'Hello World';

//2. 대괄호 문법
newObject["someKey"] = 'Hello World';

// ECMAScript 5만 호환되는 방식
//3. Object.defineProperty
Object.definePropoerty(newObject, "someKey", {
    value: '...'
    writable: true,
    enumeralbe: true,
    configurable: true
});
// 이렇게 함수로 래핑하여 간단하게도 가능
var defineProp = function (obj, key, value) {
    config.value = value
    Object.defineProperty(obj, key, config)
};

//5. Object.definedProperties
Object.defineProperties(newObject, {
    "someKey": {
        value: 'Hello world',
        writable: true
    }
})
```
이렇게 객체를 상속할 수도 있다.
```
// person이라는 객체를 상속하는 driver 객체
const driver = Object.create(person)
// 속성 할당
definedProp(driver, 'topSpeed', '100mph')
```

#### 7.2.2 생성자의 기본 특징
클래스는 새 객체를 초기화하는 `constructor()`라는 이름의 메서드를 가지고 있어야 한다. 또한 `new` 키워드는 생성자를 호출할 수 있으며 생성자 내부에서 사용된 `this` 키워드는 새로 생성된 해당 객체를 가리킨다. 
```
class Car {
    constructor(model, year, miles){
        this.model = model;
        this.year = year;
        this.miles = miles;
    }
    toString() {
        return `${this.model}....`;
    }
}

// 새로운 Car인스턴스 생성
let civic = new Car('Honda Civic', 2009, 20000);
```
위는 생성자 패턴의 간단한 예제이나 몇가지 문제가 있다.
1. 상속이 어려워짐
2. Car 생성자로 객체를 생성할 때마다 toString()과 같은 함수를 새로 정의한다.

Car 유형의 인스턴스는 모두 동일한 함수를 공유해야 하므로 이 방법은 효과적이지 않다.

> ????저렇게 쓰는게 같은 함수를 공유하는게 아닌가..?

#### 7.2.3 프로토타입을 가진 생성자
자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통메서드를 쉽게 정의할 수 있게 한다. 생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다. 이러한 방식으로 동일한 프로토타입 객체를 사용하는 여러 개의 Car객체를 만들 수 있다.
```
class Car {
    constructor(model, year, miles){
        this.model = model;
        this.year = year;
        this.miles = miles;
    }
    // 프로토타입 객체의 재정의를 피하기 위해 Object.prototype 대신
    // Object.protoType.newMethod 형태를 사용하고 있음
    // 기존에 이미 정의된 프로토타입 객체를 유지하기 위해서임
    Car.proptotype.toString = function() {
        return `${this.model}....`;
    }
}
```
> ??

### 7.3 모듈 패턴
모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는데 효과적으로 활용된다. 
초기 자바스크립트는 
- 객체 리터럴 표기법
- 모듈 패턴
- AMD 모듈
- CommonJS 모듈
와 같은 방법들로 모듈을 구현했다. 

#### 7.3.1 객체 리터럴
객체 리터럴 표기법은 객체는 중괄호({}) dksdptj 키와 값을 쉼표로 구분하여 객체를 정의하는 방법이다.
```
const myObejctLiteral = {
    variableKey: variableVAlue,
    funtionKey() {
        ///
    }
}
```
객체 리터럴은 선언 시 new 연산자를 필요로 하지않으며, `{`를 통해 객체 블록의 시작을 명시한다. 
객체 리터럴 표기법을 사용해 모듈을 정의할 수 있다.
```
const myModule = {
    myProperty: 'someValue',
    // 객체 리터럴은 속성으로 값과 메서드를 모두 가질 수 있다.
    // 예를 들어 객체 안에 객체를 다시 생성할 수도 있다.
}
```

#### 7.3.2 모듈 패턴
모듈패턴은 전통적인 소프트웨어 엔지니어링 분야에서 **클래스의 캡슐화**를 위해 처음 고안되었다.
재사용 가능한 로직을 분할하고 관리하기 위해 개별 스크립트에 의존했으며, 그 결과 하나의 HTML파일에서 10~20개의 스크립트를 각각 수동으로 가져와야 했다. 객체를 활용하는 모듈 패턴은 그저 `공개`및 `비공개` 메서드를 가진 로직을 캡슐화하는 방법 중 하나였다. 시간이 지나며 여러 커스텀 모듈 시스템이 등장했는데, 자바스크립트 모듈을 사용해 객체, 함수, 클래스,변수 등을 다른 파일에 쉽게 내보내거나 가져올 수 있게되었다.

#### 비공개
모듈 패턴은 클로저를 활용해 비공개 상태와 구성을 캡슐화한다. 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다. 모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수있다. 

ES2019(ES10) 이전의 자바스크립트에서는 접근 제한자(#)를 지원하지 않아 비공개라는 개념이 존재하지 않았다. 당시엔 변수를 공개 또는 비공개로 선언하는 방법이 없어 함수 스코프를 이용해 비공개 개념을 구현했다. 모듈 파턴에서는 클로저를 통해  비공개를 구현하여, 선언된 모듈 내부에서만 변수와 메서드를 사용할 수 있다. 하지만 반환되는 객체에 포함된 변수와 메서드는 공개되어 다른 곳에서도 사용할 수있다.

```
let counter = 0;
const testModule = {
    fn1(){
        return counter++
    }
    fn2() {
        return counter--
    }
}
export default testModule;

import testModule from './testModule'l
testModule.fn1();
testModule.fn2();
```
다른 파일들은 fn1()를 직접 읽지 못하며 counter 변수는 전역 스코프로부터 완전히 보호되어 비공개 변수로서 작동한다. 모듈의 클로저 내부로 스코프가 제한되어 오직 fn() 메서드만이 접근할 수 있다. 
- 비공개 자유성: 모듈 내부에서만 사용 가능한 비공개 함수를 자유롭게 만들 수 있다. 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.
- 디버깅 용이성: 대개 함수는 선언되고 이름이 정해지므로, 어떤 함수가 예외를 발생시켰는지 알아내려고 할때 디버거에서 콜스택을 찾기 쉬워짐.

#### 7.3.3 모듈 패턴의 변형
#### 믹스인 가져오기 변형
유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차함수에 인자로 전달할 수 있게 한다. 이를 통해 전역 스코프 요소를 가져와 맘대로 이름을 지정할 수 있다.
```
//util.js
export const min = (arr) => Math.min(...arr);

//priovateMethods.js
import {min} from './util.js';

export const privateMehod = () => {
    console.log(min([10,3,4])
}

// myModule.js
import {privateMehod} from './privateMethods';

const myModuel = () => ({
    publicMethod(){
        privateMethod();
    }
})
export default MyModule;

//main.js
import myModule from './myModule';

const moduleInstance = myModule();
moduleInstance.publicMethod();
```

#### 내보내기 변형
다음 변형은 따로 이름을 지정해주지 않고 전역 스코프로 변수를 내보낸다. 
> 예제의 privateMethod는 어디에 쓰이는 것임..?

#### 장점
자바스크립트 관점에서 볼 때 모듈 패턴은 캡슐화 개념보다 객체 지향 프로그래밍 지식을 가진 초보 개발자가 이해하 쉽다. 믹스인 가져오기를 보면 모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하고 독립적으로 만들어 준다. 
그리고 export 를 이용해 비공개를 지원한다. 
모듈 패턴은 공개되면 안되는 코드를 캡슐화 할 수 있고 여러 의존성을 동시에 사용할 수 있으며 이름의 충돌도 피할 수 있다. 다만 구버전에서 ES2015모듈을 사용하려면 바벨과 같은 트랜스파일러가 필요하다.

#### 단점
모듈 패턴의 단점은 공개와 비공개 멤버를 서로 다르게 접근해야 한다는 것이다. 공개 여부를 바꾸고 싶다면 값이 위치한 파일로 가서 각각 바꾸어주어야한다. 
또한 나중에 추가한 메서드에서는 비공개 멤버에 접근할 수 없다.
자동화 단위 테스트에서 비공개 멤버는 제외된다는 점
핫픽스가 필요한 오류를 고칠 때 복잡도를 높인다.

#### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴
ES6에서 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체이다. 키는 객체여야만 하나, 값으로는 뭐든지 넣을 수 있다. WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵이다. (=== 참조되지 않는 키는 가비지 컬렉션(GC)의 대상이 됨)
```
let _counter = new WeakMap();

class Module {
    constructor(){
        _counter.set(this, 0);
    }
    incrementCount(){
        let counter = _counter.get(this);
        counter++;
        _counter.set(this, counter);
        
        return _counter.get(this);
    }
}
```
> 현재는 비공개 필드를 지원하기때문에 weakMap을 사용하는 일은 거의 없다.

### 7.4 노출 모듈 패턴
크리스티안 하일만의 노출패턴은 공개 변수나 메서드에 접근하기 위해 가져온 메인객체의 이름을 반복해서 사용해야 한다는 점에 대해 답답함을 느끼며 생겼다. 또한 그는 객체 리터럴 표기법을 사용해 요소를 공개하는 것도 맘에 들어하지않았다.
그 결과 모든 함수와 변수를 비공개 스코프에 정의하고 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴이 탄생했다. 
ES2015+에서는 모듈 스코프 안에 정의된 함수와 변수는 비공개 처리된다. 그리고 export와 import를 통해 공개 여부를 결정한다.

#### 장점
노출 모듈 패턴을 사용하면 코드의 일관성이 유지된다. 또한 모듈의 가장 아래에위치한 공개 객체를 더 알아보기 쉽게 바꾸어 가독성을 향상시킨다. 
#### 단점
비공개 함수를 참조하는 공개함수를 수정할 수없다. 비공개 함수가 비공개 구현을 참조하기 때문에 수정을 해도 함수가 변경될 뿐 참조된 구현이 변경되는 것은 아니다. 비공개 변수를 참조하는 공개 객체 멤버 또한 수정이 불가능하다. 
따라서 노출 모듈 패턴으로 마들어진 모듈은 기존 모듈 패턴보다도 취약할 수 잇으므로 사용에 주의해야한다.
> 커스텀훅으로 많이 사용되는 방법


### 7.5 싱글톤 패턴
싱글톤패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다. 이 패턴은 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.
싱글톤 패턴을 구현하려면 이미 존재하는 인스턴스가 없어야 한다. 인스턴스가 이미 존재할 경우에는 해당 인스턴스의 참조를 반환한다. 

싱글톤 패턴은 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있는데 초기화 시점에 필요한 특정 정보가 유효하지 않을 수도 있끼 때문이다. 싱글톤 클래스의 인스턴스가 이미 생서되어ㅏㅆ다는 사실을 모른다면 해당 인스턴스를 찾아 사용하기 어렵다.
이는 **싱글톤이 객체나 클래스가 아닌 구조**이기 때문이다.

ES2015+에서는 자바스크립트 클래스의 전역 인스턴스를 단 한 번만 생성하는 싱글톤 패턴을 구현할 수 있으며, 모듈 내보내기를 통해 싱글톤 인스턴스를 바깥에서 사용할 수 있게 노출할 수도 있다. 이를 통해 싱글톤 인스턴스에 대한 접근을 좀 더 명시적이고 통제할 수있게 되며 다른 전역 변수와도 구분할 수 있다.
-> 새로운 클래스 인스턴스를 생성할 수는 없으나 클래스 내에 공개된 get, set 메서드를 통해 인스턴스를 읽거나 수정할 수 있다. 


싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용한다는 점이다.
- 클래스의 인스턴스는 정확히 하나만 있어야 하며 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야 한다.
- 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있어야하고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야한다. 

#### 7.5.1 리액트의 상태 관리
싱글톤 대신 Context API나 리덕스같은 전역 상태 관리 도구를 이용하여 개발할 수 있다. 싱글톤과는 달리, 이러한 전역 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다.


### 7.6 프로토 타입 패턴
이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
프로토타입 패턴은 프로토타입 상속을 기반으로 한다. 이패턴에서는 프로토타입 역할을 할 전용 객체를 생성하는데 이렇게 만들어진 `prototype` 객체는 생성자를 통해 만들어진 객체의 설계도가 된다. 예를들어 생성자 함수의 프로토타입이 name 속성을 가지고 있따면 해 생성자 함수를 사용해 만들어진 객체는 모두 name 속성을 가지게 된다.  

생성자 패턴 - 객체를 어떻게 만드는가 에 대한 패턴 
프로토타입 - 만들어진 객체들이 무엇을 공유하는가에 대한 매커니즘

ES2015에서는 객체를 생성하기 위해 클래스와 생성자를 사용할 수 있다. 하지만 내부적으로는 클래스와 생성자도 결국 함수와 프로토타입으로 컴파일되어버린다. 즉 클래스와 생성자를 사용한다고 하더라도 여전히 프로토타입의 장점과 동시에 성능상 이점을 누리고 있는 것이다.


### 7.7 팩토리 패턴
팩토리 패턴은 객체를 생성하는 생성 패턴의 하나이다. 다른 패턴과 달리 생성자를 필요로 하지 않지만 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다.

팩토리 패턴은 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 객체 생성과정이 복잡할 때 특히 유용하다
```
class Dog {
  speak() {
    console.log("Woof!");
  }
}
class Cat {
  speak() {
    console.log("Meow!");
  }
}

class AnimalFactory {
  static createAnimal(type) {
    switch (type) {
      case "dog":
        return new Dog();
      case "cat":
        return new Cat();
      default:
        throw new Error("Unknown animal type");
    }
  }
}

const dog = AnimalFactory.createAnimal("dog");
dog.speak(); // Woof!

const cat = AnimalFactory.createAnimal("cat");
cat.speak(); // Meow!
```
외부 코드는 단순히 Factory.createAnimal("dog")만 호출
-> 객체 생성방식을 몰라도 됨(캡슐화)

#### 7.7.1 팩토리 패턴을 사용하면 좋은 상황
- 객체나 컴포넌트 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕타이핑과 같은 API규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할때, 또한 디커플링에도 유용하다

#### 7.7.2 팩토리 패턴을 사용하면 안 되는 상황
객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 차라리 위험을 피해 생성자를 사용하는 것이 좋다. 
팩토리 패턴은 객체 생성 과정을 인터페이스 뒤에 추성화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가할 수 있다.


#### 7.7.3 추상 팩토리 패턴
추상 팩토리 패턴은 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴이다. 객체가 어떻게 생성되는지에 대한 세부사항을 알 필요 없이 객체를 사용할 수 있게 한다. 
객체의 생성 과정에서 영향을 받지 않아야 하거나 여러 타입의 객체로 작업해야하는 경우에 추상 팩토리를 사용하면 좋다.


### 7.8 구조패턴
구조패턴은 클래스와 객체의 구성을 다룬다. 구조 패턴은 클래스와 객체를 체계적으로 구성하는 최고의 방법과 사례를 제공한다
- 퍼사드 패턴
- 믹스인 패턴
- 데코레이터 패턴
- 플라이웨이트 패턴

### 7.9 퍼사드 패턴
퍼사드패턴은 심층적인 복잡성(모듈, API, 클래스 등)을 숨기고 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴이다. 

내부에는 복잡한 로직이 여러 단계로 얽혀 있지만 외부에서는 단 하나의 단순한 메서드만 호출하면 되는 구조

```
function useApi() {
  const get = async (url) => { /* axios.get + error처리 + loading */ };
  const post = async (url, body) => { /* axios.post + 공통헤더 */ };
  return { get, post };
}
```
복잡한 HTTP로직을 훅으로 감싸고 외부에선 단순히 useApi().get("/user")만 호출하면 된다.

### 7.10 믹스인 패턴
C++나 Lisp 같은 전통적인 프로그래밍 언어에서 믹스인은 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스이다.

### 7.11 서브 클래싱
서브클래싱이랑 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것을 뜻한다. 서브클래스는 부모 클래스에서 먼저 정의된 메서드를 오버라이드하는 것도 가능하다. 서브클래스의 메서드는 오버라이드된 부모 클래스의 메서드를 호출할 수도 있는데, 이를 `메서드 체이닝`이라고 부른다. 마찬가지로 부모 클래스의 생성자를 호출할 수도 있는데, 이를 `생성자 체이닝`이라고 부른다.

### 7.12 믹스인 패턴
믹스인은 최소한의 복잡성으로 객채의 기능을 빌리거나 상속할 수 잇게 해준다. 또한 믹스인은 다른 여러 클래스를 아울러 쉽게 공유할 수 있는 속성과 메서드를 가진 클래스이다.
자바스크립트의 클래스는 부모 클래스를 하나만 가질 수 있지만 여러 클래스의 기능을 섞는 것으로 문제를 해결할 수 있다. 

자바스크립트에서 클래스는 표현식뿐만 아니라 `문`으로도 사용할 수 있는데, 표현식은 평가될 때마다 새로운 클래스를 반환한다. extneds절은 클래스나 생성자를 반환하는 임의의 표현식을 허용할 수도 있다. 이러한 특징을 통해 부모 클래스를 받아 새로운 서브클래스를 만들어내는 믹스인 함수를 정의할 수 있다. 
```
// 동적으로 부모 클래스를 받아 확장하는 함수
const MyMixins = superclass => 
    class extends superclass{
        moveUp(){
            console.log('move up');
        }
        moveDown(){
            console.log(move down);
        }
        stop(){
            console.log('stop!')
        }
    }
```
#### 믹스인의 장점과 단점
믹스인은 함수의 중복을 줄이고 재사용성을 높인다. 애플리케이션에서 객체 인스턴스 사이에 공유되는 기능이 있다면 믹스인을 통해 기능을 공유하여 중복을 피하고 고유 기능을 구현하는데 집중할 수 있다.

다만 몇몇 개발자들은 클래스나 객체의 프로토타입에 기능을 주입한느 것은 나쁜 방법이라고 여긴다 (프로토타입 오염과 함수의 출처에 대한 불확실성을 초래하기 때문)


리액트에서도 ES6 클래스 도입 이전에는 컴포넌트에 기능을 추가하기 전에 믹스인을 사용하곤 했다. 하지만 컴포넌트의 유지보수와 재사용을 복잡하게 한다는 이유로 믹스인을 반대했다. 대신 고차 컴포넌트와 Hooks의 사용을 장려했다. 

### 7.13 데코레이터 패턴
데코레이터 패턴은 코드 재사용을 목표로 하는 구조패턴이다.믹스인과 마찬가지로 객체 서브클래싱의 다른 방법이라고 보면 된다. 

기본적으로 데코레이터는 기존 클래스에 동적으로 기능을 추가하기 위해 사용한다. 데코레이터 자체는 클래스의 기본 기능에 필수적이지 않다는 생각이며, 만약 필수적이었다면 부모 클래스에 이미 구현되었을 것이다. 

데코레이터 패턴은 객체의 생성을 신경 쓰지 않는 대신 기능의 확장에 좀 더 초점을 둔다. 프로토타입의 상속에 의지하기보다는 하나의 베이스 클래스에 추가 가능을 제공하는 데코레이터 객체를 점진적으로 추가한다. 이는 서브클래싱 대신 베이스 객체에 속성이나 메서드를 추가하여 간소화하겠다는 아이디어이다. 

```
Insurance(
  Engraving(
    Memory(
      MacBook()
    )
  )
)
```
Insurance.getCost() → Engraving.getCost() → Memory.getCost() → MacBook.getCost()
감싸서 누적되는 형태 -> 데코레이터

### 7.15 의사 클래스 데코레이터
더스틴 디아즈와 로스하메스가 Pro JavaScript Design Patterns 에서 선보인 데코레이터 변형 버전
인터페이스 개념을 사용하여 데코레이터가 다른 프로그래밍 언어에서는 어떻게 구현되는지에 초점을 두었다. 

인터페이스란 -> 객체가 가져야 할 메서드를 정의하는 방법
다만 어떻게 메서드를 구현해야하는지는 직접적으로 명시하지 않는다. 

### 7.16 플라이웨이트 패턴
플라이웨이터 패턴은 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결 방안이다. 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하는 목적을 가지고 있다. 
비슷한 객체나 데이터 구조에서 공통으로 사용되는 부분만을 하나의 외부 객체로 내보내는 것으로 이루어짐, 각 객체에 데이터를 저장하기보다는 하나의 의존 외부 데이터에 모아서 저장할 수 있다.

#### 7.16.1 사용법
1. 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
2. 

#### 7.16.2 데이터 공유
- 내재적 상태
    - 객체의 내부 메서드에 필요한 것이며, 없으면 절대로 동작하지 않음
    - 여러 객체가 공유할 수 있는 것
- 외재적 상태
    - 외재적 정보는 제거되어 외부에 저장될 수 있다. 
    - 객체마다 달라지는 정보

같은 내재적 정보를 지닌 객체를 팩토리 메서드를 사용해 만들어진 하나의 공유된 객체로 대체할 수있다. 
이미 공통 부분으로 인스턴스화된 객체를 재사용하면 되기 때문에 객체의 내재적 정보가 다를 경우에만 새로운 객체 복사본을 생성하면 된다. 

외재적 정보를 다룰 때에는 따로 관리자를 사용한다. 관리자는 다양한 방법으로 구현할 수 있지만, 그 중 한 가지 방법은 플라이웨이트 객체와 내재적 상태를 보관하는 중앙 데이터베이스를 관리자로 사용하는 것이다. 

