# 비동기 프로그래밍 패턴

## 비동기 프로그래밍
- 동기 코드 = blocking : 코드가 순서대로 한줄씩 실행되며 완료될때까지 기다림.
- 비동기 코드 = non-blocking : 코드가 순서대로 실행되나 비동기 함수가 있으면 백그라운드에서 실행시키도록 하고 넘어감.

- 구현방식 : 콜백 -> promise -> async/await
  - 콜백 : 콜백함수를 넘겨주는 방식
  - promise : promise 객체의 then, catch 메서드 활용
  - async/await : promise의 synatic sugar. try,catch 문을 활용

## promise, async/await 등장 배경
- 콜백을 사용하면서 콜백 지옥으로 불리는 중첩된 콜백 구조가 가독성과 유지보수를 크게 저하하는 현상 발생
- es6부터 promise, async/await가 콜백 지옥을 해결하기 위해 등장

## 프로미스 패턴
- pending, fulfilled, rejected 3가지 상태 존재.
- Promise 생성자를 사용하여 만들 수 있고 resolve, reject를 인수를 받는 함수를 인자로 받음. 
  - resolve는 성공적으로 작업이 완료되었을 때 호출
  - reject는 작업이 실패했을 떄 호출
- then, catch 메소드를 통해 요청 결과를 처리할 수 있음

- 프로미스 체이닝 : 여러개의 프로미스를 함께 연결하여 복잡한 비동기 로직 처리
- 프로미스 에러 처리 : catch 메소드 활용
- 프로미스 병렬 처리 : Promise.all 활용
- 프로미스 순차 실행 : Promise.resolve 활용
- 프로미스 메모이제이션 : 캐시 활용하여 호출 결과 저장 -> Map 활용?
- 프로미스 파이프라인 : 비동기 파이프라인 생성
- 프로미스 재시도 : retry 횟수 지정.
- 프로미스 데코레이터 : 고차 함수 사용하여 프로미스 적용
- 프로미스 경쟁 : Promise.race 활용


## async/await 패턴
- async function composition : 여러개의 비동기 함수 조합
- 비동기 반복 : for-await-of 반복문 + yield 사용
- 비동기 에러처리 : try,catch문 활용
- 비동기 순차 실행 : Promise.resolve 활용
- 비동기 메모이제이션 : 캐시 활용하여 호출 결과 저장 -> Map 활용?
- 비동기 이벤트 처리 : await 활용
- async/await 파이프라인 : 비동기 파이프라인 생성
- 비동기 재시도 : retry 횟수 지정.
- async/await 데코레이터 : 고차 함수 사용하여 프로미스 적용

