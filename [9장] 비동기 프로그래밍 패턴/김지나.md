## 09. 비동기 프로그래밍 패턴
### 9.1 비동기 프로그래밍
	•	동기 (블로킹):  앞 코드 끝날 때까지 뒤 코드는 기다림(멈춤)
	•	비동기(논블로킹):  앞 코드가 끝나지 않아도 뒤 코드가 바로 실행됨

자바스크립트에서는 callback, promise, async/await 를 사용하여 비동기 프로그래밍을 할 수있다. 

### 9.3 프로미스 패턴
프로미스는 비동기 작업의 결과를 나타내는 객채로 , 대기(pending), 완료(fulfilled), 거부(refected)의 세가지 상태를 가질 수 있다.

프로미스는 Promise 생성자를 사용하여 만들 수 있으며, 이 생성자는 함수를 인수로 받는다. 또다시 이 함수는 resolve, reject 두 개의 인수를 전달받는다. 
프로미스를 사용하면 콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다. -> 콜백 지옥을 피하고 이해하기 쉽고 유지보수성이 높은 코드를 작성할 수 있다.

#### 9.3.1 프로미스 체이닝
여러 개의 프로미스를 함계 연결하여 보다 복잡한 비동기 로직을 만들 수 있다.
```
function makeRequest(url){
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error))
  })
}

function processData(data) {
  return processData
}

makeRequest('http://test.com')
  .then(data => processData(data))
  .then(processData => console.log(data))
  .catch(error => console.log(error))
```

#### 9.3.2 프로미스 에러처리
catch 메서드를 사용하여 프로미스 체인의 실행 중에 발생할 수 있는 에러를 처리한다.

#### 9.3.3 프로미스 병렬 처리
Promise.all / allSettled 메서드를 사용하여 여러 프로미스를 동시에 실행할 수 있도록 한다.

#### 9.3.4 프로미스 순차 실행
Promise.resolve 메서드를 사용하여 프로미스를 순차적으로 실행할 수 있도록 한다.
1번의 프로미스 체이닝의 일종이라 볼 수 있으나 즉시 resolve된 빈 프로미스 객체를 시작으로 하는 점이 특징임
```
Promise.resolve()
    .then(() => makeRequest1())
    .then(() => makeRequest2())
    .then(() => makeRequest3())
    .then(() => {
      // 모든 요청 완료  
    })
```

#### 9.3.5 프로미스 메모제이션
캐시를 사용하여 프로미스 함수 호출의 결과 값을 저장한ㄷ. 이를 통해 중복된 요청을 방지한다. 
(401 에러 처리할때 많이 썼음)

#### 9.3.6 프로미스 파이프라인
함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을 생성한다

#### 9.3.7 프로미스 재시도
프로미스가 실패할 때 다시 시도할 수 있다.

#### 9.3.8 프로미스 데코레이터
고차함수를 사용하여 프로미스에 적용할 수 있는 데코레이터를 생성한다. 이를 통해 프로미스에 추가적인 기능을 부여할 수 있다.

#### 9.3.9 프로미스 경쟁
Promise.race 메서드를 사용하여 여러 프로미스를 동시에 실행하고 먼저 완료되는 프로미스의 결과를 반환한다. 

### 9.4 async.await 패턴
#### 9.4.1 비동기 조합
#### 9.4.2 비동기 반복
for-await-of 반복ㄷ문을 사용하여 비동기 반복 가능 객체를 순회할 수 있도록 한다.
### 비동기 이벤트 처리
