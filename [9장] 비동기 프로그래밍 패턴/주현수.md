### 9.3.5. Promise Memoization

```javascript

/**
 * promise memoization
 * 캐시를 이용해 프로미스 함수호출의 결과값을 저장 
 * 캐시된 데이터를 반환하는 함수
 */


const cache  = new Map<string, Promise<any>>();
function memoizedMakeRequest<T>(url){
    if(cache.has(url)){
        const cachedPromise = cache.get(url)
        return cachedPromise

    }
    
    return new Promise<T>((resolve, reject)=>{
        fetch(url).then(response=>response.json()).then(data=>{
            resolve(data)
            cache.set(url, data)
            
        }).catch(error=>{
            reject(error)
            
        })
    })
}

memoizedMakeRequest<User>("https://example.com/")
```

---
## Rtry

### 9.3.7 Promise Retry
프로미스가 실패 할 때 다시 시도할 수 있다.


```typescript

function makeRequestWithRetry(url:string){
    let attemps= 0;
    const makeRequest = ()=> new Promise((resolve, reject)=>{
        setTimeout(()=>{
            resolve("data");
        }, 1000);
    });

    const retry = error=>{
        attemps++;
        if(attemps >= 3){
            throw new Error("Failed to make request");
        }
        return makeRequest();
    }

    return makeRequest().catch(retry)
}

```






---
## 병렬/순서/경쟁

### 9.3.3 프로미스 병렬
- 결과는 모두 완료된 후 한 번에 반환
- 하나도 실패하면 전체 실패


```javascript
//공통 request 함수
function makeRequest(url: string, delay: number){
    return new Promise((resolve, reject)=>{
        if(url === "https://api.example.com/data2"){
            reject(new Error("Error from data2"));
        }
        setTimeout(()=>{
            resolve(`Response from ${url}`);
        }, delay);

    });
}
```

```javascript
Promise.all([makeRequest("https://api.example.com/data1", 1000),
        makeRequest("https://api.example.com/data2", 2000),
        makeRequest("https://api.example.com/data3", 3000),]).then(([data1, data2, data3])=>{
            cosnole.log(data1, data2, data3) 
        }).catch(err =>{
            console.log(err)
        })

```


### 9.4.4 비동기 병렬

```javascript


//비동기 병렬 
async function asyncParallel(){
    const [result1, result2, result3] = await Promise.all([
        makeRequest("https://api.example.com/data1", 1000),
        makeRequest("https://api.example.com/data2", 2000),
        makeRequest("https://api.example.com/data3", 3000),
        
    ]);
    console.log("result1", result1);
    console.log("result2", result2);
    console.log("result3", result3);
    //결과는 한번에 반환됨 (순차적으로알려주지 않음)
}

asyncparallel() // catch 'Error:Error from data2'
```


### 9.3.4 프로미스 순차 실행
Promise 체이닝 방식

```javascript
Promise.resolve().then(()=> makeRequest1()).then(()=> makeRequest2()).then(()=> makerequest3())
```
### 9.4.5 비동기 순차 실행
await순차 호출

```javascript
async function main(){
    let result = await Promise.resolve()

    result = await makeRequest1(result)
    result = await makeRequest2(result)
    result = await makeRequest3(result)

    console.log(result)
}

```

### 9.3.9 프로미스 경쟁

### 9.5.9 async/await 데코레이터 작성 

