
## 10. 모듈형 자바스크립트 패턴

확장 가능한 자바스크립트 환경에서 **모듈형**이란 서로 의존성이 낮은 기능들이 모듈로써 저장된 형태를 뜻한다.
-> 이런 느슨한 결합은 의존성을 제거하여 애플리케이션의 유지보수를 용이하게 만들어준다.

이 장에서는 ES2015 이전의 모듈을 가져오는 AMD, CommonJS, UMD에 대해서 다룬다

### 10.1 스크립트 로더
스크립트 로더는 모듈형 자바스크립트를 구현하기 위한 핵심적인 도구이며, 호환 가능한 스크립트 로더를 사용해야만 모듈형 자바스크립트를 구현할 수 있었다. 

```
// 기존의 자바스크립트
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>
// 문제점
// 1. 순서가 중요함
// 2. 전역 변수 오염 
// 3. 항상 전부 로드됨
// 4. 의존성 관리하기 힘들다
```
이를 해결하기 위해 나온 것이 스크립트 로더
-> JS 파일도 모듈처럼 의존성 선언하고 필요할때 동적으로 불러오도록
스크립트 로더가 해주는 것들
- 의존성 관리
- 로드 순서 보장
- 비동기 로딩
- 모듈 스코프 제공


### 10.2 AMD
`AMD(Asynchronous Nodule Definition)` 모듈 형식은 모듈과 의존성 모두를 비동기적으로 로드 할 수 있도록 설계된 방식이다.
(주로 브라우저에서 모듈을 비동기로 로딩하려고 만든 방식)

	•	정의: define(module_id?, [...deps]?, function (...) { ... })
	•	사용: require([...deps], function (...) { ... })
	
```
// math.js
define([], function () {
  function add(a, b) {
    return a + b;
  }
  return { add };
});
```
```
// app.js
require(["math"], function (math) {
  console.log(math.add(1, 2));
});
```

#### AMD가 모듈형 자바스크립트 작성에 더 좋은이유
- 유연한 모듈 정의방식에 대한 명확한 제안을 제공한다
- 기존에 많이 사용되고 있는 전역 네임스페이스나 <script>태그 방식에 비해 훨씬 더 구조화되어있다. 독립적인 모듈과 의존성을 명확하게 선언할 수 있다.
- 모듈정의가 독립적으로 이루어지기 때문에 전역 네임스페이스의 오염을 방지할 수 있다.
- 일부 대체 솔루션에 비해 더 효과적이라는 주장이 있다. 다른 크로스 도메인, 로컬환경, 디버깅에서 문제가 없으며 서버사이드 툴을 사용할 필요도 없다. 대부분의 AMD 로더는 빌드 과정 없이 브라우저에서 모듈을 로딩하는 것을 지원한다.
- 여러 모듈을 하나의 파일로 가져오기 위한 전송 방식을 제공한다. CommonJS와 같은 다른 방식은 아직 전송 형식에 도입하지 못하고 있다.
- 스크립트의 지연 로딩을 지원한다.


### 10.3 CommonJS
서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안, AMD와 달리 I/O, 파일 시스템, 프로미스 등 더욱 광범위한 부분을 다룬다. 
	•	내보내기: module.exports 또는 exports
	•	가져오기: require()
```
// math.js
function add(a, b) {
  return a + b;
}
module.exports = { add };
```
```
// app.js
const { add } = require("./math");
console.log(add(1, 2));
```
- 동기 로딩이 기본 
    - require() 호출하면 그 자리에서 파일 읽고 실행해서 결과를 줌
- 따라서 서버(Node)환경에 잘 맞음
     - 서버는 파일 시스템 접근이 빠르고 안정적이라 즉시 로딩이 괜찮음

기본적으로 Node.js는 다음과 같은 파일을 CommonJS 모듈로 인식한다
- .cjs 확장자를 가진 파일
- 가장 가까이에 위치한 package.json파일 안에 type 항목의 값이 commonjs로 되어있는 경우, .js확장자를 가진 파일
- 가장 가까이에 위치한 package.json 파일 안에 type 항목이 존재하지 않는 경우, .js 확장자를 가진 파일
- .mjs, .cjs, .json, .js 이외의 확장자를 가진 파일


require() 함수를 호출하면 항상 CommonJS 모듈 로더가 사용되고, import() 함수를 호출하면 항상 ECMAScript 모듈 로더가 사용된다. 가장 가까이에 위치한 package.json 파일에 설정된 type 값과 관계없이 항상 적용된다. 

### 10.4.1 UMD
UMD(Universal Module Definition)는 이 코드가 어디서 실행되든(브라우저, Node) 동작하게 하자 라는 목적의 모듈 패턴

라이브러리 하나 만들고 싶은데…
	•	어떤 사람은 브라우저 + RequireJS(AMD) 사용
	•	어떤 사람은 Node + CommonJS
	•	어떤 사람은 아무 모듈 시스템도 안 씀
-> 라이브러리 하나에 배포본 3개를 만들기 너무 귀찮음

==> 실행 환경을 감지해서 알아서 맞는 방식으로 export 하는 방식 -> UMD

하지만 트리쉐이킹x, 타입추론x, ESM 등장 이후로는 레거시 취급
```
dist/
 ├─ index.esm.js      ← modern (ESM)
 ├─ index.cjs.js      ← Node (CommonJS)
 └─ index.umd.js      ← 레거시 대응
```









